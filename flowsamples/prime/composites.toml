flow = "composites"

[[input]]
name = "limit"
type = "number"

# Generate a sequence of divisors from 2, upto sqrt(limit) (e.g. limit = 9, 2..3)
[[process]]
source = "lib://flowstdlib/math/sqrt"
#
[[connection]]
from = "input/limit"
to = "sqrt"
[[process]]
alias = "divisors"
source = "lib://flowstdlib/math/sequence"
input.start = {once =  2}
input.step = {once =  1}
[[connection]]
from = "sqrt"
to = "divisors/limit"
# buffer the output
[[process]]
alias = "divisors-buffer"
source = "lib://flowstdlib/data/buffer"
[[connection]]
from = "divisors/sequence"
to = "divisors-buffer"

## generate a sequence of composites - i.e. non-primes

# start at at 2 x divisor - no point in generating composites from the divisor itself
# e.g. if start = 2, first composite will be 4
[[process]]
source = "lib://flowstdlib/math/multiply"
input.i2 = {always =  2}
[[connection]]
from = "divisors-buffer"
to = "multiply/i1"
[[connection]]
from = "multiply"
to = "composite-sequence/start"

# the step each time will be the divisors. e.g. 2, 3
[[connection]]
from = "divisors-buffer"
to = "composite-sequence/step"

# buffer the limit so it can be reused each time
[[process]]
alias = "limit-buffer"
source = "lib://flowstdlib/data/buffer"
#
[[connection]]
from = "input/limit"
to = "limit-buffer"
[[connection]] # loopback
from = "limit-buffer"
to = "limit-buffer"
# and send to sequence as upper limit
[[connection]]
from = "limit-buffer"
to = "composite-sequence/limit"

# generate the sequence-of-sequences of composites as an output
# [start = 4, step = 2, limit = 9] -> [4, 6, 8]
# [start = 6, step = 3, limit = 9] -> [6, 9]
[[process]]
alias = "composite-sequence"
source = "lib://flowstdlib/math/sequence"
[[output]]
name = "composites"
type = "number"
[[connection]]
from = "composite-sequence/sequence"
to = "output/composites"




