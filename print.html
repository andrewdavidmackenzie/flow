<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The &#x27;flow&#x27; Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to &#x27;flow&#x27;: what it is and how to use it">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="docs/book_intro.html">Intro</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction to flow</li><li class="chapter-item expanded "><a href="docs/introduction/what_is_flow.html"><strong aria-hidden="true">1.</strong> What is flow?</a></li><li class="chapter-item expanded "><a href="docs/introduction/tenets.html"><strong aria-hidden="true">2.</strong> Tenets of flow</a></li><li class="chapter-item expanded "><a href="docs/introduction/structure.html"><strong aria-hidden="true">3.</strong> Project Components and Structure</a></li><li class="chapter-item expanded "><a href="docs/introduction/inspirations.html"><strong aria-hidden="true">4.</strong> The Inspirations for flow</a></li><li class="chapter-item expanded "><a href="docs/introduction/non_inspirations.html"><strong aria-hidden="true">5.</strong> Non-Inspirations</a></li><li class="chapter-item expanded "><a href="docs/introduction/parallelism.html"><strong aria-hidden="true">6.</strong> Parallelism</a></li><li class="chapter-item expanded "><a href="docs/introduction/status.html"><strong aria-hidden="true">7.</strong> Status</a></li><li class="chapter-item expanded affix "><li class="part-title">Your First Flow</li><li class="chapter-item expanded "><a href="docs/first_flow/first_flow.html"><strong aria-hidden="true">8.</strong> Your First Flow</a></li><li class="chapter-item expanded "><a href="docs/first_flow/implementation.html"><strong aria-hidden="true">9.</strong> Running the flow</a></li><li class="chapter-item expanded "><a href="docs/first_flow/step-by-step.html"><strong aria-hidden="true">10.</strong> Step-by-Step</a></li><li class="chapter-item expanded "><a href="docs/first_flow/debugging.html"><strong aria-hidden="true">11.</strong> Debugging your first flow</a></li><li class="chapter-item expanded affix "><li class="part-title">Guide to Defining Flows</li><li class="chapter-item expanded "><a href="docs/describing/definition_overview.html"><strong aria-hidden="true">12.</strong> Defining flows</a></li><li class="chapter-item expanded "><a href="docs/describing/names.html"><strong aria-hidden="true">13.</strong> Names</a></li><li class="chapter-item expanded "><a href="docs/describing/ios.html"><strong aria-hidden="true">14.</strong> Flow IOs</a></li><li class="chapter-item expanded "><a href="docs/describing/process_references.html"><strong aria-hidden="true">15.</strong> Process References</a></li><li class="chapter-item expanded "><a href="docs/describing/function_definitions.html"><strong aria-hidden="true">16.</strong> Function Definitions</a></li><li class="chapter-item expanded "><a href="docs/describing/types.html"><strong aria-hidden="true">17.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="docs/describing/connections.html"><strong aria-hidden="true">18.</strong> Connections</a></li><li class="chapter-item expanded "><a href="docs/describing/flow_libraries.html"><strong aria-hidden="true">19.</strong> Flow Libraries</a></li><li class="chapter-item expanded "><a href="docs/describing/context_functions.html"><strong aria-hidden="true">20.</strong> Context Functions</a></li><li class="chapter-item expanded "><a href="docs/describing/provided_functions.html"><strong aria-hidden="true">21.</strong> Provided Functions</a></li><li class="chapter-item expanded "><a href="docs/describing/programming_methods.html"><strong aria-hidden="true">22.</strong> Programming Methods</a></li><li class="chapter-item expanded affix "><li class="part-title">flowr's context functions</li><li class="chapter-item expanded "><a href="flowr/src/cli/args/args.html"><strong aria-hidden="true">23.</strong> Arg functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flowr/src/cli/args/get.html"><strong aria-hidden="true">23.1.</strong> Arg get function</a></li></ol></li><li class="chapter-item expanded "><a href="flowr/src/cli/file/file.html"><strong aria-hidden="true">24.</strong> File functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flowr/src/cli/file/file_write.html"><strong aria-hidden="true">24.1.</strong> File Write function</a></li></ol></li><li class="chapter-item expanded "><a href="flowr/src/cli/image/image.html"><strong aria-hidden="true">25.</strong> Image manipulation functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flowr/src/cli/image/image_buffer.html"><strong aria-hidden="true">25.1.</strong> Image buffer</a></li></ol></li><li class="chapter-item expanded "><a href="flowr/src/cli/stdio/stdio.html"><strong aria-hidden="true">26.</strong> Standard IO functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flowr/src/cli/stdio/readline.html"><strong aria-hidden="true">26.1.</strong> Readline function</a></li><li class="chapter-item expanded "><a href="flowr/src/cli/stdio/stdin.html"><strong aria-hidden="true">26.2.</strong> Standard Input function</a></li><li class="chapter-item expanded "><a href="flowr/src/cli/stdio/stdout.html"><strong aria-hidden="true">26.3.</strong> Standard Output function</a></li><li class="chapter-item expanded "><a href="flowr/src/cli/stdio/stderr.html"><strong aria-hidden="true">26.4.</strong> Standard Error function</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Running Flows</li><li class="chapter-item expanded "><a href="docs/running/running.html"><strong aria-hidden="true">27.</strong> Running flows</a></li><li class="chapter-item expanded "><a href="docs/running/flowc.html"><strong aria-hidden="true">28.</strong> flowc Command Line Arguments</a></li><li class="chapter-item expanded "><a href="docs/running/arguments.html"><strong aria-hidden="true">29.</strong> Passing command line arguments to flows</a></li><li class="chapter-item expanded "><a href="docs/running/root_file_selection.html"><strong aria-hidden="true">30.</strong> Specifying the root file to load</a></li><li class="chapter-item expanded "><a href="docs/running/stdio.html"><strong aria-hidden="true">31.</strong> Standard Input and Output</a></li><li class="chapter-item expanded "><a href="docs/running/panics.html"><strong aria-hidden="true">32.</strong> Exceptions and Panics</a></li><li class="chapter-item expanded "><a href="docs/running/flowr.html"><strong aria-hidden="true">33.</strong> Running Flows using flowr</a></li><li class="chapter-item expanded "><a href="docs/running/client_server.html"><strong aria-hidden="true">34.</strong> Running a flow in client/server mode of flowr</a></li><li class="chapter-item expanded "><a href="docs/running/distributed.html"><strong aria-hidden="true">35.</strong> Distributed execution of jobs with flowr and flowrex</a></li><li class="chapter-item expanded affix "><li class="part-title">Debugging Flows</li><li class="chapter-item expanded "><a href="docs/debugging/debugger.html"><strong aria-hidden="true">36.</strong> The Debugger</a></li><li class="chapter-item expanded affix "><li class="part-title">The flowstdlib Standard Library</li><li class="chapter-item expanded "><a href="docs/developing/flowstdlib.html"><strong aria-hidden="true">37.</strong> Overview</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/control/control.html"><strong aria-hidden="true">38.</strong> control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flowstdlib/src/control/compare_switch/compare_switch.html"><strong aria-hidden="true">38.1.</strong> compare_switch</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/control/index/index.html"><strong aria-hidden="true">38.2.</strong> index</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/control/index_f.html"><strong aria-hidden="true">38.3.</strong> index_f</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/control/join/join.html"><strong aria-hidden="true">38.4.</strong> join</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/control/route/route.html"><strong aria-hidden="true">38.5.</strong> route</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/control/select/select.html"><strong aria-hidden="true">38.6.</strong> select</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/control/tap/tap.html"><strong aria-hidden="true">38.7.</strong> tap</a></li></ol></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/data.html"><strong aria-hidden="true">39.</strong> data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flowstdlib/src/data/accumulate/accumulate.html"><strong aria-hidden="true">39.1.</strong> accumulate</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/append/append.html"><strong aria-hidden="true">39.2.</strong> append</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/count/count.html"><strong aria-hidden="true">39.3.</strong> count</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/duplicate/duplicate.html"><strong aria-hidden="true">39.4.</strong> duplicate</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/duplicate_rows/duplicate_rows.html"><strong aria-hidden="true">39.5.</strong> duplicate_rows</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/enumerate/enumerate.html"><strong aria-hidden="true">39.6.</strong> enumerate</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/info/info.html"><strong aria-hidden="true">39.7.</strong> info</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/multiply_row/multiply_row.html"><strong aria-hidden="true">39.8.</strong> multiply_row</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/ordered_split/ordered_split.html"><strong aria-hidden="true">39.9.</strong> ordered_split</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/remove/remove.html"><strong aria-hidden="true">39.10.</strong> remove</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/sort/sort.html"><strong aria-hidden="true">39.11.</strong> sort</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/split/split.html"><strong aria-hidden="true">39.12.</strong> split</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/transpose/transpose.html"><strong aria-hidden="true">39.13.</strong> transpose</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/data/zip/zip.html"><strong aria-hidden="true">39.14.</strong> zip</a></li></ol></li><li class="chapter-item expanded "><a href="flowstdlib/src/fmt/fmt.html"><strong aria-hidden="true">40.</strong> fmt</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flowstdlib/src/fmt/reverse/reverse.html"><strong aria-hidden="true">40.1.</strong> reverse</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/fmt/to_json/to_json.html"><strong aria-hidden="true">40.2.</strong> to_json</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/fmt/to_string/to_string.html"><strong aria-hidden="true">40.3.</strong> to_string</a></li></ol></li><li class="chapter-item expanded "><a href="flowstdlib/src/math/math.html"><strong aria-hidden="true">41.</strong> math</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flowstdlib/src/math/add/add.html"><strong aria-hidden="true">41.1.</strong> add</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/math/compare/compare.html"><strong aria-hidden="true">41.2.</strong> compare</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/math/divide/divide.html"><strong aria-hidden="true">41.3.</strong> divide</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/math/multiply/multiply.html"><strong aria-hidden="true">41.4.</strong> multiply</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/math/range.html"><strong aria-hidden="true">41.5.</strong> range</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/math/range_split/range_split.html"><strong aria-hidden="true">41.6.</strong> range_split</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/math/sequence.html"><strong aria-hidden="true">41.7.</strong> sequence</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/math/sqrt/sqrt.html"><strong aria-hidden="true">41.8.</strong> sqrt</a></li><li class="chapter-item expanded "><a href="flowstdlib/src/math/subtract/subtract.html"><strong aria-hidden="true">41.9.</strong> subtract</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Sample flows</li><li class="chapter-item expanded "><a href="docs/developing/flowsamples.html"><strong aria-hidden="true">42.</strong> Samples Intro</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flowsamples/args/DESCRIPTION.html"><strong aria-hidden="true">42.1.</strong> args</a></li><li class="chapter-item expanded "><a href="flowsamples/arrays/DESCRIPTION.html"><strong aria-hidden="true">42.2.</strong> arrays</a></li><li class="chapter-item expanded "><a href="flowsamples/factorial/DESCRIPTION.html"><strong aria-hidden="true">42.3.</strong> factorial</a></li><li class="chapter-item expanded "><a href="flowsamples/fibonacci/DESCRIPTION.html"><strong aria-hidden="true">42.4.</strong> fibonacci</a></li><li class="chapter-item expanded "><a href="flowsamples/hello-world/DESCRIPTION.html"><strong aria-hidden="true">42.5.</strong> hello-world</a></li><li class="chapter-item expanded "><a href="flowsamples/mandlebrot/DESCRIPTION.html"><strong aria-hidden="true">42.6.</strong> mandlebrot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flowsamples/mandlebrot/escapes/escapes.html"><strong aria-hidden="true">42.6.1.</strong> escapes</a></li><li class="chapter-item expanded "><a href="flowsamples/mandlebrot/pixel_to_point/pixel_to_point.html"><strong aria-hidden="true">42.6.2.</strong> pixel_to_point</a></li></ol></li><li class="chapter-item expanded "><a href="flowsamples/matrix_mult/DESCRIPTION.html"><strong aria-hidden="true">42.7.</strong> matrix multiplication</a></li><li class="chapter-item expanded "><a href="flowsamples/pipeline/DESCRIPTION.html"><strong aria-hidden="true">42.8.</strong> pipeline</a></li><li class="chapter-item expanded "><a href="flowsamples/prime/DESCRIPTION.html"><strong aria-hidden="true">42.9.</strong> prime</a></li><li class="chapter-item expanded "><a href="flowsamples/primitives/DESCRIPTION.html"><strong aria-hidden="true">42.10.</strong> primitives</a></li><li class="chapter-item expanded "><a href="flowsamples/reverse-echo/DESCRIPTION.html"><strong aria-hidden="true">42.11.</strong> reverse-echo</a></li><li class="chapter-item expanded "><a href="flowsamples/router/DESCRIPTION.html"><strong aria-hidden="true">42.12.</strong> router</a></li><li class="chapter-item expanded "><a href="flowsamples/sequence/DESCRIPTION.html"><strong aria-hidden="true">42.13.</strong> sequence</a></li><li class="chapter-item expanded "><a href="flowsamples/sequence-of-sequences/DESCRIPTION.html"><strong aria-hidden="true">42.14.</strong> sequence-of-sequences</a></li><li class="chapter-item expanded "><a href="flowsamples/tokenizer/DESCRIPTION.html"><strong aria-hidden="true">42.15.</strong> tokenizer</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Developing flow</li><li class="chapter-item expanded "><a href="docs/developing/overview.html"><strong aria-hidden="true">43.</strong> Developing flow</a></li><li class="chapter-item expanded "><a href="docs/developing/prereqs.html"><strong aria-hidden="true">44.</strong> Pre-requisites</a></li><li class="chapter-item expanded "><a href="docs/developing/building.html"><strong aria-hidden="true">45.</strong> Building</a></li><li class="chapter-item expanded "><a href="docs/developing/crates.html"><strong aria-hidden="true">46.</strong> Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/developing/flowcore.html"><strong aria-hidden="true">46.1.</strong> flowcore</a></li><li class="chapter-item expanded "><a href="docs/developing/flowmacro.html"><strong aria-hidden="true">46.2.</strong> flowmacro</a></li><li class="chapter-item expanded "><a href="docs/developing/flowrlib.html"><strong aria-hidden="true">46.3.</strong> flowrlib</a></li><li class="chapter-item expanded "><a href="docs/developing/flowr.html"><strong aria-hidden="true">46.4.</strong> flowr</a></li><li class="chapter-item expanded "><a href="docs/developing/flowrex.html"><strong aria-hidden="true">46.5.</strong> flowrex</a></li><li class="chapter-item expanded "><a href="docs/developing/flowc.html"><strong aria-hidden="true">46.6.</strong> flowc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flowc/tests/test-flows/README.html"><strong aria-hidden="true">46.6.1.</strong> Test flows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flowc/tests/test-flows/hello-world/hello-world.html"><strong aria-hidden="true">46.6.1.1.</strong> hello-world</a></li><li class="chapter-item expanded "><a href="flowc/tests/test-flows/line-echo/line-echo.html"><strong aria-hidden="true">46.6.1.2.</strong> line-echo</a></li><li class="chapter-item expanded "><a href="flowc/tests/test-flows/print-args/print-args.html"><strong aria-hidden="true">46.6.1.3.</strong> print-args</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="docs/developing/flowstdlib.html"><strong aria-hidden="true">46.7.</strong> flowstdlib</a></li><li class="chapter-item expanded "><a href="docs/developing/flowsamples.html"><strong aria-hidden="true">46.8.</strong> flowsamples</a></li></ol></li><li class="chapter-item expanded "><a href="docs/developing/make.html"><strong aria-hidden="true">47.</strong> Makefile targets</a></li><li class="chapter-item expanded "><a href="docs/developing/contributing.html"><strong aria-hidden="true">48.</strong> Ways to contribute</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/developing/issues.html"><strong aria-hidden="true">48.1.</strong> Issues</a></li><li class="chapter-item expanded "><a href="docs/developing/prs.html"><strong aria-hidden="true">48.2.</strong> PRs</a></li><li class="chapter-item expanded "><a href="docs/developing/flowsamples.html"><strong aria-hidden="true">48.3.</strong> Developing a sample</a></li><li class="chapter-item expanded "><a href="docs/developing/ci.html"><strong aria-hidden="true">48.4.</strong> Continuous Integration Tests</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Internals of the flow Project</li><li class="chapter-item expanded "><a href="docs/internals/overview.html"><strong aria-hidden="true">49.</strong> Internals of flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/internals/flow_loading.html"><strong aria-hidden="true">49.1.</strong> Flow Loading</a></li><li class="chapter-item expanded "><a href="docs/internals/flow_compiling.html"><strong aria-hidden="true">49.2.</strong> Flow Compiling</a></li><li class="chapter-item expanded "><a href="docs/internals/flow_execution.html"><strong aria-hidden="true">49.3.</strong> Flow Execution</a></li><li class="chapter-item expanded "><a href="docs/internals/state_transitions.html"><strong aria-hidden="true">49.4.</strong> Flow Execution State Transitions</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The &#x27;flow&#x27; Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome!</a></h1>
<p>Welcome to <code>flow</code>, a system for defining and running parallel, 
<a href="https://en.wikipedia.org/wiki/Dataflow_programming">dataflow programs</a> like this one:</p>
<p><img src="docs/first_flow/first.svg" alt="First flow" /></p>
<p>Page through this guide using the '&gt;' and '&lt;' buttons on the side of the page or navigating directly
to a section using the Table of Contents on the left.</p>
<p>The top-level sections are:</p>
<ul>
<li><a href="docs/introduction/what_is_flow.html">Introduction to Flow</a></li>
<li><a href="docs/first_flow/first_flow.html">Your First Flow</a></li>
<li><a href="docs/describing/definition_overview.html">Defining flows</a></li>
<li><a href="docs/running/running.html">Running flows</a></li>
<li><a href="docs/developing/flowr.html">The <code>flowr</code> runner</a></li>
<li><a href="docs/debugging/debugger.html">Debugging Flows</a></li>
<li><a href="docs/developing/flowstdlib.html">The Flow Standard Library</a></li>
<li><a href="docs/developing/flowsamples.html">Sample flows</a></li>
<li><a href="docs/developing/overview.html">Developing Flow</a></li>
<li><a href="docs/internals/overview.html">Internals of the Flow Project</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-flow"><a class="header" href="#what-is-flow">What is 'flow'</a></h1>
<p><code>flow</code> is a system for defining and running inherently parallel, data-dependency-driven 'programs'.</p>
<p>Wikipedia defines <a href="https://en.wikipedia.org/wiki/Dataflow_programming">dataflow programs</a> as </p>
<pre><code>&quot;dataflow programming is a programming paradigm that models a program as a directed 
graph of the data flowing between operations&quot;
</code></pre>
<p>which pretty much sums it up.</p>
<p>A <code>flow</code> program is created by defining a directed graph of <code>processes</code> that process data and that are
connected by <code>connections.</code></p>
<p>A <code>process</code> can have zero or more inputs and produces zero or one output. They have no side-effects.
There is no shared-memory.</p>
<p>In <code>flow</code> a <code>process</code> is a generic term. A <code>process</code> can be a <code>function</code> that directly implements the 
processing on data, or it can be a nested &quot;sub-flow&quot;. 
i.e. Another <code>flow</code> definition, that in turn may contains <code>functions</code> and/or other <code>sub-flows</code>.
When we wish to refer to them indistinctly, we will use the term process <code>process</code>. When distinctions
need to be made we will use <code>function</code>, <code>flow</code> or <code>sub-flow</code>.</p>
<p>Thus, a <code>flow</code> is an organization object, used to hierarchically organize sub-flows and functions,
and <code>functions</code> are what actually get work done on data.</p>
<p>Flows can be nested infinitely, but eventually end in <code>functions</code>. Functions consist of a definition
(for the compiler and the human programmer) and an implementation (for the runtime to use to process data).</p>
<p>The <code>connections</code> between processes are explicit declarations of data dependencies between them.
i.e. what data is required for a process to be able to run, and what output it produces.</p>
<p>Thus a <code>flow</code> is inherently parallel, without any further need to express the parallelism of the described 
algorithm.</p>
<p>As part of describing the <code>connections</code>, I would like <code>flow</code> to be also visual, making the data 
dependencies visible and directly visually &quot;author-able&quot;, but this is still a work in progress and a 
declarative text format for flow definitions was a step on the way and what is currently used.</p>
<p>Functions and sub-flows are interchangeable and nestable, so that higher level programs can be
constructed by combining <code>functions</code> and nested <code>flows</code>, making flows reusable.</p>
<p>I don't consider flow a &quot;programming language&quot;, as the functionality of the program is created from the 
combination of functions, that can be very fine grained and implemented in many programming 
languages (or even assembly, WebAssembly or something else). </p>
<p>Program logic (control flow, loops) emerges from how the processes are &quot;wired together&quot; in 'flows'. </p>
<p>I have chosen to implement the functions included with <code>flow</code> (in the <code>flowstdlib</code> standard 
library and the <code>context functions</code> of the <code>flowr</code> flow runner) in in rust, but they could be in other
languages.</p>
<p>I don't consider <code>flow</code> (or the flow description format) a DSL. The file format is chosen for describing 
a flow in text. The file format is not important, providing it can describe the flow (<code>processes</code> and
<code>connections</code>).</p>
<p>I chose TOML as there was good library support for parsing it in rust and it's a bit easier on the eyes 
than writing JSON. I later implemented multiple deserializers, so the flow description can be in other 
formats (including json and yaml) and even to be able to mix and combine descriptions in multiple formats.</p>
<p>Q. Is it high-level or low-level? </p>
<p>A. &quot;Well...yes&quot;. </p>
<p>The level of granularity chosen for the implementation of <code>functions</code> that flows are built from is arbitrary. 
A <code>function</code> could be as simple as adding two numbers, or it could implement a complex algorithm.</p>
<h2 id="interchangeability-of-functions-and-sub-flows-as-processes"><a class="header" href="#interchangeability-of-functions-and-sub-flows-as-processes">Interchangeability of <code>functions</code> and <code>sub-flows</code> as <code>processes</code></a></h2>
<p>A number of simple primitive functions can be combined together into a flow which appears as a complex 
process to the user, or it could be a complex <code>funtion</code> that implements the entire algorithm in code in
a single function.</p>
<p>The users of the process should not need to know how it is implemented. 
They see the process definition of it's inputs and outputs, a description of the processing it performs,
and use it indistinctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fundamental-tenets-of-flow"><a class="header" href="#fundamental-tenets-of-flow">Fundamental tenets of 'flow'?</a></h2>
<p>The 'tenets', or fundamental design principles, of <code>flow</code> that I have strived to meet include:</p>
<h2 id="no-global-or-shared-memory"><a class="header" href="#no-global-or-shared-memory">No Global or shared memory</a></h2>
<p>The only data within <code>flow</code> is that flowing on the connections between processes. There is no way to 
store global state, share variables between functions nor persist data across multiple function invocations.</p>
<h2 id="pure-functions"><a class="header" href="#pure-functions">Pure Functions</a></h2>
<p>Functions have no side-effects (except <code>context functions</code> which I'll describe later). Jobs for functions
are created with a set of inputs and they produce an output, and the output should only depend on the input,
along the lines of &quot;pure&quot; functions in Functional Programming. Thus a function should be able to be 
invoked multiple times and always produce the same output. Also, functions can be executed by different
threads, processes, machines and machines architectures and always produce the same output.</p>
<p>This helps make flow execution predictable, but also parallelizable. Functions can be ran in parallel or 
interleaved without any dependency on the other functions that may have ran before, those running at the 
same time, or those in the future - beyond their input values.</p>
<p>This can enable novel tracing and debugging features also such as &quot;time travel&quot; (going backwards in a program)
or &quot;un-executing&quot; a function (stepping backwards).</p>
<h2 id="encapsulation"><a class="header" href="#encapsulation">Encapsulation</a></h2>
<p>The complexity of a process is hidden inside it's definition and you don't need to know it's 
implementation to know how to use it. </p>
<ul>
<li>Public specification of a <code>process</code>: inputs and outputs for the compiler and user and a text description 
of what processing it performs on its inputs and what output(s) it produces, for the human programmer.</li>
<li>Private implementation. A <code>process</code> implementation can be a <code>function</code> implemented in code or an entire 
sub-flow containing many sub-layers and eventually functions.</li>
</ul>
<p>A process's implementation should be able to be changed, and changed from a function to a sub-flow or
vice versa without affecting flow programs that use it.</p>
<h2 id="re-usability"><a class="header" href="#re-usability">Re-usability</a></h2>
<p>Enabled by encapsulation. A well defined process can be used in many other flows via references to it.
Facilitate the &quot;packing&quot; of processes (be they functions or sub-flows) for re-use by others in other
flows.</p>
<h2 id="portability"><a class="header" href="#portability">Portability</a></h2>
<p>The intention is that the run-time can run on many platforms. The libraries have been written to
be able to compile to WASM and be portable across machines and machine architectures.</p>
<p>The function implementations in libraries are compiled to native for performance but also to WASM for
portability. Function implementations provided by the user as part of a flow are compiled to WASM once, 
then distributed with the flow and run by any of the run-times, making the flow portable without re-compilation.</p>
<h2 id="polyglot"><a class="header" href="#polyglot">Polyglot</a></h2>
<p>Although the compiler and runtimes are written in one language (rust), others versions could be written in 
other languages, there should be nothing in flow semantics or flow definition specific to one language.</p>
<p>Process implementations supplied with a flow could be written in any language that can compile to WASM, 
so it can then be distributed with the flow and then loaded and run by any run-time implementation.</p>
<h2 id="functional-decomposition"><a class="header" href="#functional-decomposition">Functional Decomposition</a></h2>
<p>Enable a problem to be decomposed into a number of communicating processes, and those in 
turn can be decomposed and so on down in a hierarchy of processes until functions are used. Thus the 
implementation is composed of a number of processes, some of which maybe reused from elsewhere and some specific to
the problem being solved.</p>
<h2 id="structured-data"><a class="header" href="#structured-data">Structured Data</a></h2>
<p>Data that flows between processes can be defined at a high-level, but consist of a complex structure or 
multiple levels of arrays of data, and processes and sub-processes can select sub-elements as input for their 
processing.</p>
<h2 id="inherently-parallel"><a class="header" href="#inherently-parallel">Inherently Parallel</a></h2>
<p>By making data dependencies between processes the basis of the definition of a flow, the non-parallel 
aspects of a flow (when one process depends on data from a previous process) are explicit, leading 
to the ability to execute all processes that <em>can</em> execute (due to the availability of data for them to 
operate on) at any time, in parallel with other executions of other processes, or of other instances 
of the same process.</p>
<p>The level of concurrency in a flow program depends only on the data structures used and the 
connections between the processes that operate on them. Then the level of parallelism exploited in its
execution depends on the resources available to the flow runner program running the flow.</p>
<h2 id="distributable"><a class="header" href="#distributable">Distributable</a></h2>
<p>As the functions are pure, and only depend on their inputs, they maybe executed across threads, cores,
processes, machines and (via portability and WASM) even a heterogeneous network of machines of different
CPU architectures and operating systems.</p>
<h2 id="separate-the-program-from-the-context"><a class="header" href="#separate-the-program-from-the-context">Separate the program from the context</a></h2>
<p>There is an explicit separation between the flow program itself, and the environment in which it runs.
Flows contain only pure functions, but they are run by a &quot;flow runner&quot; program (such as <code>flowr</code>) that
provides &quot;impure&quot; <code>context functions</code> for interacting with the context in which it is runs, for things
like STDIO, File System, etc.</p>
<h2 id="efficiency"><a class="header" href="#efficiency">Efficiency</a></h2>
<p>When there is no data to process, no processes are running and the flow and the flow runner program 
running it are idle.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="project-components-and-structure"><a class="header" href="#project-components-and-structure">Project Components and Structure</a></h2>
<p>Here is a summary of the project components, their purpose and a link to their <code>README.md</code>:</p>
<ul>
<li><a href="docs/introduction/../developing/flowcore.html">flowcore</a> - A set of core structs and traits used by <code>flowr</code> and <code>flowc</code> plus code 
to fetch content from file/http and resolve library (lib://) references.</li>
<li><a href="docs/introduction/../developing/flowmacro.html">flowmacro</a> - A macro used to help write function implementation code that compile natively
and to wasm</li>
<li><a href="docs/introduction/../developing/flowc.html">flowc</a> - The <code>flowc</code> flow compiler binary is a CLI built around <code>flowclib</code> that 
takes a number of command line arguments and source files or URLs and compiles the flow or library referenced.
<ul>
<li><code>flowclib</code> is the library for compiling flow program and library definitions from toml 
files, producing generated output projects that can be run by <code>flowr</code>.</li>
</ul>
</li>
<li><a href="docs/introduction/../developing/flowr.html">flowrlib</a> - The flow runner library that loads and executes compiled flows.</li>
<li><a href="docs/introduction/../developing/flowr.html">flowr</a> - The <code>flowr</code> flow runner binary that can be used to run and debug </li>
<li>flows compiled with a flow compiler such as <code>flowc</code>.</li>
<li><a href="docs/introduction/../developing/flowstdlib.html">flowstdlib</a> - the flow &quot;standard library&quot; which contains a set of functions that can be 
used by flows being defined by the user</li>
<li><a href="docs/introduction/../developing/flowsamples.html">samples</a> - A set of sample flows</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-inspirations-for-flow"><a class="header" href="#the-inspirations-for-flow">The Inspirations for 'flow'</a></h1>
<p>I have had many sources of inspiration in this area over the past three decades.</p>
<p>Without realizing it they started to coalesce in my head and seemingly unrelated ideas from very different areas
started to come together to form what I eventually called 'flow' and I started to work on it.</p>
<p>The impetus to actually implement something, instead of just thinking about it, came when I was looking for some
&quot;serious&quot;, more complex, project in order to learn  rust (and later adding WebAssembly to the mix).</p>
<p>It should be noted, that this project was undertaken in a very &quot;personal&quot; (i.e. idiosyncratic) way, without
any formal background in the area of functional programming, data flow programming, communicating serial
processes or similar. When starting it, I wanted to see if any of my intuitions and ideas could work, ignoring
previous efforts or established knowledge and previous projects. I didn't want to get &quot;sucked in&quot; to just 
re-implementing someone else's ideas.</p>
<p>I have done quite a bit of reading of paper on these areas after getting a reasonable version of <code>flow</code> working
and saw I was repeating a number of existing ideas and techniques..no surprise!</p>
<h2 id="specific-inspirations-from-my-career"><a class="header" href="#specific-inspirations-from-my-career">Specific inspirations from my career</a></h2>
<p>I have worked with these technologies listed below over the decares (from University until now) and they all added
something to the idea for flow in my head.</p>
<ul>
<li>The <a href="https://en.wikipedia.org/wiki/Transputer">Inmos transputer</a> chip and its 
<a href="https://en.wikipedia.org/wiki/Occam_(programming_language)">Occam</a> parallel programming
language (which I studied at University in the '80's), without realizing that this was based on Hoare's CSP.
<ul>
<li>Parallel programming language (although not based on data dependencies)</li>
<li>Parallel hardware 8and software processes) that communicated by sending messages over connections (some virtual in
software, others over hardware between chips)</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Structured_analysis_and_design_technique">Structured Analysis and Design</a> from 
my work with it in HP the '80s!
<ul>
<li>Hierarchical functional decomposition</li>
<li>Encapsulation</li>
<li>Separation of Program from Context</li>
</ul>
</li>
<li>UNIX pipes
<ul>
<li>Separate processes, each responsible for limited functionality, communicating in a pipeline via messages (text) </li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Trace_scheduling">Trace scheduling</a> for compiler instruction scheduling based on data
dependencies between instructions (operations) work done at <a href="https://en.wikipedia.org/wiki/Multiflow">MultiFlow</a> and
later HP by Josh Fisher, Paolo Faraboschi and others.
<ul>
<li>Exploiting inherent parallelism by identifying data dependencies between operations</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Amoeba_(operating_system)">Amoeba distributed OS</a> by Andrew Tannenbaum that made a 
collaborating network of computers appear as one to the user of a &quot;Workstation&quot;
<ul>
<li>Distribution of tasks not requiring &quot;IO&quot;, abstraction of what a machine is and how a computer program can run</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Yahoo!_Pipes">Yahoo! Pipes</a> system for building &quot;Web Mashups&quot;
<ul>
<li>Visual assembly of a complex program from simpler process by connecting them together with data flows</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="non-inspirations"><a class="header" href="#non-inspirations">Non-Inspirations</a></h2>
<p>There are a number of things that you might suspect were part of my set of inspirations
for creating 'flow', or maybe you think I even copied the idea from them, but that in fact
(you'll have to trust me on this one) is not true.</p>
<p>I didn't study Computer Science, and if I had I may well have been exposed to some of these
subjects a long-time ago. That would probably have saved me a lot of time.</p>
<p>But, then I would have been implementing someone else's ideas and not (what I thought were)
my own. Think of all the satisfaction I would have lost out on while re-inventing thirty to 
forty year-old ideas!</p>
<p>While implementing the first steps of 'flow' I started to see some materials come up in
my Internet searches, that looked like they could be part of a theory of the things I
was struggling with. The Main one would be Hoare's 1976 paper on the &quot;Theory of
Communicating Sequential Processes&quot; (or CSP for short).</p>
<p>It turns out some of that based work was the basis for some of my inspirations (e.g.
Inmos Transputer and Occam language), unbeknownst to me.</p>
<p>But I decided to deliberately ignore them as I worked out my first thoughts, did
the initial implementation and got some simple examples up and running!</p>
<p>Later, I looped back and read some papers, and confirmed most of my conjectures. </p>
<p>I got a bit bored with the algebra approach to it (and related papers) though and didn't
read or learn too much.</p>
<p>One Hoare paper refers more to a practical implementation, and does hit on a number of the
very subjects I was struggling with, such as the buffering (or not) of data on &quot;data flows&quot;
between functions (or processes in his terms).</p>
<p>Once I progress some more, I will probably go back and read more of these papers and books and 
find solutions to the problems I have struggled to work out on my own - but part of the
purpose of this project for me is the intellectual challenge to work them out for myself, as 
best as I can.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallelism"><a class="header" href="#parallelism">Parallelism</a></h1>
<p>Using <code>flow</code> algorithms can be defined that exploit multiple types of parallelism:</p>
<ul>
<li>Data Parallelism</li>
<li>Pipelining</li>
<li>Divide and Conquer</li>
</ul>
<h2 id="data-parallelism"><a class="header" href="#data-parallelism">Data Parallelism</a></h2>
<p>Also known as &quot;Single Program Multiple Data&quot;.</p>
<p>In this case the data is such that it can be segmented and worked on in parallel, using the same basic algorithm
for each chunk of data.</p>
<p>An example would be some image processing or image generation task, such as generating the mandlebrot set
(see the <a href="docs/introduction/../../flowsamples/mandlebrot/DESCRIPTION.html">mandlebrot</a> example in <code>flowsamples</code>).</p>
<p>The two-dimensional space is broken up into a 2D Array of pixels or points, and then they are streamed through
a function or sub-flow that does some processing or calculation, producing a new 2D Array of output values.</p>
<p>Due to the data-independence between them, all of them can be calculated/processed in parallel, across many
threads or even machines, exploiting the inherent parallelism of this &quot;embarrassingly parallel&quot; algorithm.</p>
<p>They need to be combined in some way to produce the meaningful output. This could be using an additional sub-flow
to combine them (e.g. produce an average intensity or color of an image), that is <em>not</em> parallel, or it 
could be to render them as an image for the user. </p>
<p>In the case of producing a file or image for the user, functions can be used for that from
the flow runner's <code>context functions</code> leaving the flow itself totally parallel.</p>
<p>In a normal procedural language, an image would be rendered in memory in a 2D block of pixels and then 
written out to file sequentially so that the pixels are placed in the correct order/location in the file.</p>
<p>In a flow program, that could be gone, although accumulating the 2D array in memory may represent a bottleneck.
<code>flowr</code>'s <a href="docs/introduction/../../flowr/src/cli/image/image_buffer.html">image buffer</a> <code>context function</code> is written such that it can 
accept pixels in any random order and render them correctly, but having the following inputs:</p>
<pre><code>### Inputs
* `pixel` - the (x, y) coordinate of the pixel
* `value` - the (r, g, b) triplet to write to the pixel
* `size`  - the (width, height) of the image buffer
* `filename` - the file name to persist the buffer to
</code></pre>
<h2 id="map-reduce"><a class="header" href="#map-reduce">Map Reduce</a></h2>
<p>Map-Reduce is done similar to above, using a more complex initial step to form independent data &quot;chunks&quot;
(&quot;Mapping&quot;) that can be processed totally in parallel, and a combining phase (&quot;Reducing) to produce the 
final output.</p>
<h2 id="pipelining"><a class="header" href="#pipelining">Pipelining</a></h2>
<p>A <code>flow</code> program to implement pipeline processing of data is trivial and there is a 
<a href="docs/introduction/../../flowsamples/pipeline/DESCRIPTION.html">pipeline</a> example in<code>flowsamples</code>.</p>
<p>A series of processes (they can be <code>functions</code> or <code>subflows</code>) are defined. Input data is connected to flow
to the first, whose output is sent to the second, and so on and the output rendered for the user.</p>
<p>When multiple data values are sent in in short succession (additional values are sent before the first value
has propagated out of the output) then multiple of the processes can run in parallel, each one operating on
a different data value, as there is no data or processing dependency between the data values.</p>
<p>If there are enough values (per unit time) to demand it, multiple instances of the same processes can be used
to increase parallelism, doing the same operation multiple times in parallel on different data values.</p>
<h2 id="divide-and-conquer"><a class="header" href="#divide-and-conquer">Divide and Conquer</a></h2>
<p>Just as in procedural programming, a large problem can be broken down into separate pieces and 
programmed separately, this can be done with <code>flow</code>.</p>
<p>A complex problem could be broken down into two (say) largely independent sub-problems. Each one can 
be programmed in different sub-flows, and fed different parts (or copies) of the input data. Then when 
both produce output they can be combined in some way for the user.</p>
<p>As there is no data dependency between the sub-flow outputs (intermediate values in the grander scheme of
things) they can run totally in parallel. </p>
<p>If the two values were just need to be output to the user, then they can each proceed at their own pace
(in parallel) and each one output when complete. In this case the order of the values in the output to the
user might vary, and appropriate labelling to understand them will be needed.</p>
<p>Depending on how the values need to be combined, or if a strict order in the output is required,
then a later ordering or combining step maybe needed. This step will necessarily depends on both sub-flow's
output value, thus introducing a data dependency and this final step will operate without parallelism.</p>
<p>Providing the final (non-parallel step) is less compute intensive than the earlier steps, an overall 
gain can be made by dividing and conquering (and then combining).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>The semantics of flows, processes and connections along with the implementation of the <code>flowc</code> compiler, <code>flowr</code> 
runner, <code>context</code> functions and the <code>flowstdlib</code> library has allowed for the 
creation of a set of example flows that execute as expected.</p>
<p>There has pretty good overall test coverage (&gt; 82%) that allows for safer refactoring.</p>
<p>The docs are reasonably extensive but can always be improved. They probably need &quot;real users&quot; (not the author)
to try to use them and flow to make the next round of improvements. There are issues in the repo
and the <a href="https://github.com/users/andrewdavidmackenzie/projects/2/views/1">project</a> related to improving docs.</p>
<p>I moved some GUI/IDE experimentation into a separate repo that uses the <code>flowclib</code>  and <code>flowrlib</code> libs.
The intention is to re-start some GUI experimentation with <code>egui</code> or <code>iced</code> rust GUI libraries when 1.0
is released.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-flow"><a class="header" href="#first-flow">First flow</a></h1>
<p>Without knowing anything about <code>flow</code> and its detailed semantics you might be able to guess what this flow 
below does when executed and what the output to STDOUT will be. <img src="docs/first_flow/first.svg" alt="First flow" />
It is a fibonacci series generator.</p>
<h2 id="understanding-the-flow"><a class="header" href="#understanding-the-flow">Understanding the flow</a></h2>
<p>NOTE:You can find a complete description of flow semantics in the next
section <a href="docs/first_flow/../describing/definition_overview.html">Defining Flows</a></p>
<h3 id="root-flow"><a class="header" href="#root-flow">Root flow</a></h3>
<p>All flows start with a root &quot;flow definition&quot;. Other sub-flows can be nested under the root, via references to 
separate flow description files, to enable encapsulation and flow reuse.</p>
<p>In this case it is the only one, and no hierarchy of flows descriptions is used or needed.
You can see the TOML root flow definition for this flow in the flowsample crate's fibonacci sample.
<a href="docs/first_flow/../../flowsamples/fibonacci/root.toml">root.toml</a></p>
<h3 id="interaction-with-the-execution-environment"><a class="header" href="#interaction-with-the-execution-environment">Interaction with the execution environment</a></h3>
<p>The root defines what the interaction with the surrounding execution environment is,
such as <a href="docs/first_flow/../../flowr/src/cli/stdio/stdout.html">Stdout</a>, or any other <code>context function</code> provided by the flow runtime 
being used (e.g. <code>flowr</code>).</p>
<p>The only interaction with the execution environment in this example is the use of <code>stdout</code> to print the numbers
in the series to the Terminal.</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p>Functions are stateless, and pure, and just take a set of inputs (one on each of its inputs) and produce an output.</p>
<p>When all the inputs of a function have a value, then the function can run and produce an output, or not
produce outputs, as in the case of the impure <code>stdout</code> function.</p>
<p>This flow uses two functions (shown as orange ovals):</p>
<ul>
<li><code>stdout</code> from the <code>context functions</code> as described above
<ul>
<li><code>stdout</code> only has one, unnamed, default input and no outputs. It will print the value on STDOUT of the process
running the flow runner (<code>flowr</code>) that is executing the flow.</li>
</ul>
</li>
<li>the <code>add</code> function from the flow standard library <code>flowstdlib</code> to add two integers together.
<ul>
<li><code>add</code> has two inputs &quot;i1&quot; and &quot;i2&quot; and produces the sum of them on the only, unnamed, &quot;default&quot; output.</li>
</ul>
</li>
</ul>
<h3 id="connections"><a class="header" href="#connections">Connections</a></h3>
<p>Connections (the solid lines) take the output of a function when it has ran, and send it to the input of connected 
functions. They can optionally have a name.</p>
<p>When a functions has ran, the input values used are made available again at the output. </p>
<p>In this case the following three connections exist:</p>
<ul>
<li>&quot;i2&quot; input value is connected back to the &quot;i1&quot; input.</li>
<li>the output of &quot;add&quot; (the sum of &quot;i1&quot; and &quot;i2&quot;) is connected back to the &quot;i2&quot; inputs. This connection has optionally 
been called &quot;sum&quot;</li>
<li>the output of &quot;add&quot; (the sum of &quot;i1&quot; and &quot;i2&quot;) is connected to the default input of &quot;Stdout&quot;. This connection has 
optionally been called &quot;sum&quot;</li>
<li></li>
</ul>
<h3 id="initializations"><a class="header" href="#initializations">Initializations</a></h3>
<p>Inputs of processes (flows or functions) can be initialized with a value &quot;Once&quot; (at startup) or &quot;Always&quot; (each time 
it ran) using input initializers (dotted lines)</p>
<p>In this example two input initializers are used to setup the series calculation</p>
<ul>
<li>&quot;Once&quot; initializer with value &quot;1&quot; in the &quot;i2&quot; input of &quot;add&quot;</li>
<li>&quot;Once&quot; initializer with value &quot;0&quot; in the &quot;i1&quot; input of &quot;add&quot;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-the-flow"><a class="header" href="#running-the-flow">Running the flow</a></h1>
<p>This flow exists as a sample in the <code>flowsamples/fibonacci</code> folder. See the 
<a href="docs/first_flow/../../flowsamples/fibonacci/root.toml">root.toml</a> root flow definition file</p>
<p>You can run this flow and observe its output from the terminal, while in the flow project root folder:</p>
<pre><code class="language-shell script">&gt; cargo run -p flowc -- -C flowr/src/cli flowsamples/fibonacci
</code></pre>
<p><code>flowc</code> will compile the flow definition from the root flow definition file (<code>root.toml</code>) using the <code>context functions</code>
offered by <code>flowr</code> (defined in the <code>flowr/src/cli</code> folder) to generate a <code>manifest.json</code> compiled flow manifest in the 
<code>flowsamples/fibonacci</code> folder.</p>
<p><code>flowc</code> then runs <code>flowr</code> to execute the flow.</p>
<p><code>flowr</code> is a Command Line flow runner and provides implementations for <code>context</code> functions to read and write to <code>stdio</code> (e.g. <code>stdout</code>).</p>
<p>The flow will produce a fibonacci series printed to Stdout on the terminal.</p>
<pre><code class="language-shell script">&gt; cargo run -p flowc -- -C flowr/src/cli flowsamples/fibonacci
   Compiling flowstdlib v0.6.0 (/Users/andrew/workspace/flow/flowstdlib)
    Finished dev [unoptimized + debuginfo] target(s) in 1.75s
     Running `target/debug/flowc flowsamples/first`
1
2
3
5
8
...... lines deleted ......
2880067194370816120
4660046610375530309
7540113804746346429
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="step-by-step"><a class="header" href="#step-by-step">Step-by-Step</a></h2>
<p>Here we walk you through the execution of the previous &quot;my first flow&quot; (the fibonacci series sample).</p>
<p>Compiled flows consist of only functions, so flow execution consists of executing functions, or more precisely, jobs
formed from a set of inputs, and a reference to the function implementation.</p>
<h3 id="init"><a class="header" href="#init">Init</a></h3>
<p>The flow manifest (which contains a list of Functions and their output connections) is loaded.</p>
<p>Any function input that has an input initializer on it, is initialized with the value provided in the initializer.</p>
<p>Any function that has either no inputs (only <code>context funcitons</code> are allowed to have no inputs, such as <code>Stdin</code>) or
has a value on all of its inputs, is set to the ready state.</p>
<h3 id="execution-loop"><a class="header" href="#execution-loop">Execution Loop</a></h3>
<p>The next function that is in the ready state (has all its input values available, and is not blocked from sending 
its output by other functions) has a job created from its input values and the job is dispatched to be run.</p>
<p>Executors wait for jobs to run, run them and then return the result, that may or may not contain an output value.</p>
<p>Any output value is sent to all functions connected to the output of the function that the job ran for. 
Sending an input value to a function may make that function ready to run.</p>
<p>The above is repeated until there are no more functions in the ready state, then execution has terminated and the flow ends.</p>
<h3 id="specific-sequence-for-this-example"><a class="header" href="#specific-sequence-for-this-example">Specific Sequence for this example</a></h3>
<p>Below is a description of what happens in the flor runtime to execute the flow.</p>
<p>You can see log output (printed to STDOUT and mixed with the number series output) of what is happening using 
the <code>-v, verbosity &lt;Verbosity Level&gt;</code> command line option to <code>flowr</code>. </p>
<ul>
<li>Values accepted (from less to more output verbosity) are: <code>error</code> (the default), <code>warn</code>, <code>info</code> <code>debug</code> and <code>trace</code>.</li>
</ul>
<h4 id="init-1"><a class="header" href="#init-1">Init:</a></h4>
<ul>
<li>The &quot;i2&quot; input of the &quot;add&quot; function is initialized with the value 1</li>
<li>The &quot;ii&quot; input of the &quot;add&quot; function is initialized with the value 0</li>
<li>The &quot;add&quot; function has a value on all of its inputs, so it is set to the ready state</li>
<li>STDOUT does not have an input value available so it is not &quot;ready&quot;</li>
</ul>
<h4 id="loop-starts"><a class="header" href="#loop-starts">Loop Starts</a></h4>
<p>Ready = [&quot;add&quot;]</p>
<ul>
<li>&quot;add&quot; runs with Inputs = (0, 1) and produces output 1
<ul>
<li>value 1 from output of &quot;add&quot; is sent to input &quot;i2&quot; of &quot;add&quot;
<ul>
<li>&quot;add&quot; only has a value on one input, so is NOT ready</li>
</ul>
</li>
<li>value 1 from output of &quot;add&quot; is sent to default (only) input of &quot;Stdout&quot;
<ul>
<li>&quot;Stdout&quot; has a value on all of its (one) inputs and so is marked &quot;ready&quot;</li>
</ul>
</li>
<li>input value &quot;i2&quot; (1) of the executed job is sent to input &quot;i1&quot; of &quot;add&quot;
<ul>
<li>&quot;add&quot; now has a value on both its inputs and is marked &quot;ready&quot;</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Ready = [&quot;Stdout&quot;, &quot;add&quot;]</p>
<ul>
<li>&quot;Stdout&quot; runs with Inputs = (1) and produces no output
<ul>
<li>&quot;Stdout&quot; converts the <code>number</code> value to a <code>String</code> and prints &quot;1&quot; on the STDOUT of the terminal</li>
<li>&quot;Stdout&quot; no longer has values on its inputs and is set to not ready</li>
</ul>
</li>
</ul>
<p>Ready = [&quot;add&quot;]</p>
<ul>
<li>&quot;add&quot; runs with Inputs = (1, 1) and produces output 2
<ul>
<li>value 2 from output of &quot;add&quot; is sent to input &quot;i2&quot; of &quot;add&quot;
<ul>
<li>&quot;add&quot; only has a value on one input, so is NOT ready</li>
</ul>
</li>
<li>value 2 from output of &quot;add&quot; is sent to default (only) input of &quot;Stdout&quot;
<ul>
<li>&quot;Stdout&quot; has a value on all of its (one) inputs and so is marked &quot;ready&quot;</li>
</ul>
</li>
<li>input value &quot;i2&quot; (1) of the executed job is sent to input &quot;i1&quot; of &quot;add&quot;
<ul>
<li>&quot;add&quot; now has a value on both its inputs and is marked &quot;ready&quot;</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Ready = [&quot;Stdout&quot;, &quot;add&quot;]</p>
<ul>
<li>&quot;Stdout&quot; runs with Inputs = (2) and produces no output
<ul>
<li>&quot;Stdout&quot; converts the <code>number</code> value to a <code>String</code> and prints &quot;2&quot; on the STDOUT of the terminal</li>
<li>&quot;Stdout&quot; no longer has values on its inputs and is set to not ready</li>
</ul>
</li>
</ul>
<p>Ready = [&quot;add&quot;]</p>
<p>The above sequence proceeds, until eventually:</p>
<ul>
<li><code>add</code> function detects a numeric overflow in the add operation and outputs no value.
<ul>
<li>No value is fed back to the &quot;i1&quot; input of add 
<ul>
<li>&quot;add&quot; only has a value on one input, so is NOT ready</li>
</ul>
</li>
<li>No value is sent to the input of &quot;Stdout&quot;
<ul>
<li>&quot;Stdout&quot; no longer has values on its inputs and is set to not ready</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Ready = []</p>
<p>No function is ready to run, so flow execution ends.</p>
<p>Resulting in a fibonacci series being output to Stdout</p>
<pre><code>1
2
3
5
8
...... lines deleted ......
2880067194370816120
4660046610375530309
7540113804746346429
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="debugging-your-first-flow"><a class="header" href="#debugging-your-first-flow">Debugging your first flow</a></h2>
<h3 id="command-line-options-to-flowc"><a class="header" href="#command-line-options-to-flowc">Command line options to <code>flowc</code></a></h3>
<p>When running <code>flowc</code> using <code>cargo run -p flowc</code> you should add <code>--</code> to mark the end of the options passed to cargo, 
and the start of the options passed to <code>flowc</code></p>
<p>You can see what they are using <code>--help</code> producing output similar to this:</p>
<pre><code class="language-bash">cargo run -p flowc -- --help                         
    Finished dev [unoptimized + debuginfo] target(s) in 0.12s
     Running 'target/debug/flowc --help'
flowc 0.8.8

USAGE:
    flowc [FLAGS] [OPTIONS] [--] [ARGS]

FLAGS:
    -d, --dump        Dump the flow to .dump files after loading it
    -z, --graphs      Create .dot files for graph generation
    -h, --help        Prints help information
    -l, --lib         Compile a flow library
    -p, --provided    Provided function implementations should NOT be compiled from source
    -s, --skip        Skip execution of flow
    -g, --symbols     Generate debug symbols (like process names and full routes)
    -V, --version     Prints version information

OPTIONS:
    -L, --libdir &lt;LIB_DIR|BASE_URL&gt;...    Add a directory or base Url to the Library Search path
    -o, --output &lt;OUTPUT_DIR&gt;             Specify the output directory for generated manifest
    -i, --stdin &lt;STDIN_FILENAME&gt;          Read STDIN from the named file
    -v, --verbosity &lt;VERBOSITY_LEVEL&gt;     Set verbosity level for output (trace, debug, info, warn, error (default))

ARGS:
    &lt;FLOW&gt;            the name of the 'flow' definition file to compile
    &lt;flow_args&gt;...    Arguments that will get passed onto the flow if it is executed

</code></pre>
<h3 id="command-line-options-to-flowr"><a class="header" href="#command-line-options-to-flowr">Command line options to <code>flowr</code></a></h3>
<p>By default <code>flowc</code> uses <code>flowr</code> to run the flow once it has compiled it. Also it defaults to passing the <code>-n/--native</code>
flag to <code>flowr</code> so that flows are executed using the native implementations of library functions.</p>
<p>In order to pass command line options on to <code>flowr</code> you separate them from the options to <code>flowc</code> after another <code>--</code> separator.</p>
<p><code>flowr</code> accepts the same <code>-v/--verbosity</code> verbosity options as <code>flowc</code>.</p>
<h3 id="getting-debug-output"><a class="header" href="#getting-debug-output">Getting debug output</a></h3>
<p>If you want to follow what the run-time is doing in more detail, you can increase the verbosity level (default level is ERROR)
using the <code>-v/--verbosity</code> option.</p>
<p>So, if you want to walk through each and every step of the flow's execution, similar to the previous <a href="docs/first_flow/step-by-step.html">step by step section</a> 
then you can do so by using <code>-v debug</code> and piping the output to <code>more</code> (as there is a lot of output!):</p>
<p><code>cargo run -p flowc -- samples/fibonacci -- -v debug| more</code></p>
<p>which should produce output similar to this:</p>
<pre><code class="language-bash">INFO    - 'flowr' version 0.8.8
INFO    - 'flowrlib' version 0.8.8
DEBUG   - Loading library 'context' from 'native'
INFO    - Library 'context' loaded.
DEBUG   - Loading library 'flowstdlib' from 'native'
INFO    - Library 'flowstdlib' loaded.
INFO    - Starting 4 executor threads
DEBUG   - Loading flow manifest from 'file:///Users/andrew/workspace/flow/flowsamples/fibonacci/manifest.json'
DEBUG   - Loading libraries used by the flow
DEBUG   - Resolving implementations
DEBUG   - Setup 'FLOW_ARGS' with values = '[&quot;my-first-flow&quot;]'
INFO    - Maximum jobs dispatched in parallel limited to 8
DEBUG   - Resetting stats and initializing all functions
DEBUG   - Init: Initializing Function #0 '' in Flow #0
DEBUG   -               Input initialized with 'Number(0)'
DEBUG   -               Input initialized with 'Number(1)'
DEBUG   - Init: Initializing Function #1 '' in Flow #0
DEBUG   - Init: Creating any initial block entries that are needed
DEBUG   - Init: Readying initial functions: inputs full and not blocked on output
DEBUG   -               Function #0 not blocked on output, so added to 'Ready' list
DEBUG   - ===========================    Starting flow execution =============================
DEBUG   - Job #0:-------Creating for Function #0 '' ---------------------------
DEBUG   - Job #0:       Inputs: [[Number(0)], [Number(1)]]
DEBUG   - Job #0:       Sent for execution
DEBUG   - Job #0:       Outputs '{&quot;i1&quot;:0,&quot;i2&quot;:1,&quot;sum&quot;:1}'
DEBUG   -               Function #0 sending '1' via output route '/sum' to Self:1
DEBUG   -               Function #0 sending '1' via output route '/sum' to Function #1:0
DEBUG   -               Function #1 not blocked on output, so added to 'Ready' list
DEBUG   -               Function #0 sending '1' via output route '/i2' to Self:0
DEBUG   -               Function #0, inputs full, but blocked on output. Added to blocked list
DEBUG   - Job #1:-------Creating for Function #1 '' ---------------------------
DEBUG   - Job #1:       Inputs: [[Number(1)]]
DEBUG   -                               Function #0 removed from 'blocked' list
DEBUG   -                               Function #0 has inputs ready, so added to 'ready' list
DEBUG   - Job #1:       Sent for execution
DEBUG   - Job #2:-------Creating for Function #0 '' ---------------------------
DEBUG   - Job #2:       Inputs: [[Number(1)], [Number(1)]]
1
DEBUG   - Job #2:       Sent for execution
DEBUG   - Job #2:       Outputs '{&quot;i1&quot;:1,&quot;i2&quot;:1,&quot;sum&quot;:2}'
DEBUG   -               Function #0 sending '2' via output route '/sum' to Self:1
DEBUG   -               Function #0 sending '2' via output route '/sum' to Function #1:0
DEBUG   -               Function #1 not blocked on output, so added to 'Ready' list
DEBUG   -               Function #0 sending '1' via output route '/i2' to Self:0
DEBUG   -               Function #0, inputs full, but blocked on output. Added to blocked list
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="guide-to-defining-flows"><a class="header" href="#guide-to-defining-flows">Guide to Defining Flows</a></h2>
<p>In this guide to defining flows, we will describe the syntax of definitions files, but also the run-time semantics
of flows, functions, jobs, inputs etc in order to understand how a flow will run when defined.</p>
<p>A flow is a static hierarchical grouping of functions that produce and consume data, connected via 
connections  into a graph.</p>
<h3 id="root-flow-1"><a class="header" href="#root-flow-1">Root Flow</a></h3>
<p>All flows have a <code>root</code> flow definition file.</p>
<p>The root flow can reference functions provided by the &quot;flow runner&quot; application that will execute the flow, 
for the purpose of interacting with the surrounding environment (such as file IO, standard IO, etc). 
These are the <code>context functions</code>.</p>
<p>The root flow (as any sub-flow can) may include references to sub-flows and functions, joined by connections between 
their inputs and outputs, and so on down in a hierarchy.</p>
<p>The root flow cannot have any input or output. As such, all data flows start or end in the root flow. What you
might consider &quot;outputs&quot;, such as printing to standard output, is done by describing a connection to a <code>context  functions</code> that interacts with the environment.</p>
<h3 id="flows-in-general"><a class="header" href="#flows-in-general">Flows in General</a></h3>
<p>Any flow can contain references to functions it uses, plus zero or more references to nested flows via <a href="docs/describing/process_references.html">Process 
References</a>, and so on down.</p>
<p>Data flows internally between sub-flows and functions (collectively known as &quot;processes&quot;), as defined by the 
connections.</p>
<p>All computation is done by functions. A flow is just a hierarchical organization method that allows to group
and abstract groups of functions (and sub-flows) into higher level concepts. All data that flows originates in
a function and terminates in a function. </p>
<p>flow and sub-flow nesting is just an organizational technique to facilitate encapsulation and re-use of functionality,
and does not affect program semantics.</p>
<p>Whether a certain process in a flow is implemented by one more complex function - or by a sub-flow combining multiple,
simpler, functions - should not affect the program semantics.</p>
<h3 id="valid-elements-of-a-flow-definition"><a class="header" href="#valid-elements-of-a-flow-definition">Valid Elements of a flow definition</a></h3>
<p>Valid entries in a flow definition include:</p>
<ul>
<li><code>flow</code> - A String naming this flow (obligatory)</li>
<li><code>docs</code> - An optional name of an associated markdown file that documents the flow</li>
<li><code>version</code> - A SemVer compatible version number for this flow (Optional)</li>
<li><code>authors</code> - Array of Strings of names and emails of authors of the flow (Optional)</li>
<li><code>input</code>|<code>output</code> - 0 or more input/outputs of this flow made available to any parent including it (Note: 
that the root flow may not contain any inputs or outputs). See <a href="docs/describing/ios.html">IOs</a> for more details.</li>
<li><code>process</code> - 0 or more references to sub-processes to include under the current flow. A sub-process
can be another <code>flow</code> or a <code>function</code>. See <a href="docs/describing/process_references.html">Process References</a> for more details.</li>
<li><code>connection</code> - 0 or more connections between io of sub-processes and/or <code>io</code> of this flow. See <a href="docs/describing/connections.html">Connections</a>
for more details.</li>
</ul>
<h3 id="complete-feature-list"><a class="header" href="#complete-feature-list">Complete Feature List</a></h3>
<p>The complete list of features that can be used in the description of flows is:</p>
<ul>
<li>Flow definitions
<ul>
<li>Named inputs and outputs (except root flow which has no parent)</li>
<li>References to sub-processes to use them in the flow via connections
<ul>
<li>Functions
<ul>
<li>Provided functions</li>
<li>Library functions</li>
<li>Context functions</li>
</ul>
</li>
<li>Sub-flows
<ul>
<li>Arbitrarily from the file system or the web</li>
<li>From a library</li>
</ul>
</li>
<li>Initializers for sub-process inputs and the flow outputs
<ul>
<li><code>Once</code> initializers that initialize the input/output with a value just once at the start of flow execution</li>
<li><code>Always</code> initializers that initialize the input/output every time it is emptied by the creation of a job that 
takes the value.</li>
</ul>
</li>
<li>Use of aliases to refer to sub-process with different names inside a flow, facilitating the use of the same
function or flow multiple times for different purposes within the sub-flow</li>
</ul>
</li>
<li>Connections between outputs and inputs within a flow
<ul>
<li>Connections can be formed between inputs to flow or outputs of one process (function or flow) and outputs
of the flow or inputs of a process</li>
<li>Multiple connections from a source</li>
<li>Multiple connections to a destination</li>
<li>Connection to/from a default input/output by just referencing the process in the connection</li>
<li>Destructuring of output struct in a connection to just connect a sub-part o fit</li>
<li>Optional naming of a connection to facilitate debugging</li>
</ul>
</li>
</ul>
</li>
<li>Function definitions
<ul>
<li>With just inputs</li>
<li>With just outputs</li>
<li>With inputs and outputs</li>
<li>default single input/output, named single input/output, named multiple inputs/outputs</li>
<li>author and versioning meta-data and references to the implementation</li>
</ul>
</li>
<li>Libraries of processes (functions and flows) can be built and described, and referenced in flows</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="name"><a class="header" href="#name">Name</a></h2>
<p>A string used to identify an element.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="io"><a class="header" href="#io">IO</a></h2>
<p>IOs produce or consume data of a specific type, and are where data enters/leaves a flow or function (more generally 
referred to as &quot;processes&quot;).</p>
<ul>
<li><code>name</code> - used to identify an input or output in connections to/from it</li>
<li><code>type</code> (optional) - An optional <a href="docs/describing/types.html">Data type</a> for this IO</li>
</ul>
<h3 id="default-inputs-and-outputs"><a class="header" href="#default-inputs-and-outputs">Default inputs and outputs</a></h3>
<p>If a function only has one input or one output, then naming that input/output is optional.
If not named, it is referred to as the default input. Connections may connect data to/from this input/output just
by referencing the function.</p>
<h3 id="generic-inputs-or-outputs"><a class="header" href="#generic-inputs-or-outputs">Generic Inputs or Outputs</a></h3>
<p>If an input or output has no specific <a href="docs/describing/types.html">Data type</a> specified, then it is considered <code>generic</code> and can 
take inputs of any type. What the function does, or what outputs it produces, may vary depending on the input
type at runtime and should be specified by the implementor of the function and understood by the flow programmer
using it.</p>
<p>Example: A print function could accept any type and print out some human readable representation of all of them.</p>
<p>Example: An <code>add</code> function could be overloaded and if provided two numbers it would sum them, but if provided
two strings it could concatenate them.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="process-reference"><a class="header" href="#process-reference">Process Reference</a></h2>
<p>Flows may reference a another flow or a function (generically referred to as a <code>process</code>) which is defined in a
separate definition file. These are &quot;process references&quot;</p>
<h3 id="process-reference-fields"><a class="header" href="#process-reference-fields">Process Reference Fields</a></h3>
<ul>
<li><code>source</code> - A Url (or relative path) of a file/resource where the process is defined. </li>
</ul>
<p>For example, here we reference a process called <code>stdout</code> (see <a href="docs/describing/context_functions.html">context functions</a>)</p>
<pre><code class="language-toml">[[process]]
source = &quot;context://stdio/stdout&quot;
</code></pre>
<p>This effectively brings the function into scope with the name <code>stdout</code> and it can then be used in connections
as a source or destination of data.</p>
<h4 id="alias-for-a-process-reference"><a class="header" href="#alias-for-a-process-reference">Alias for a Process Reference</a></h4>
<ul>
<li><code>alias</code> - an alias to use to refer to a process in this flow.
<ul>
<li>This can be different from the <code>name</code> defined by the process itself</li>
<li>This can be used to create two or more instances of a process in a flow,
and the ability to refer to them separately and distinguish them in connections.</li>
</ul>
</li>
</ul>
<p>For example, here the process called <code>stdout</code> is aliased as <code>print</code>and then can be referred to using <code>print</code>in
connections.</p>
<pre><code class="language-toml">[[process]]
alias = &quot;print&quot;
source = &quot;context://stdio/stdout&quot;
</code></pre>
<h4 id="source-url-formats"><a class="header" href="#source-url-formats">Source Url formats</a></h4>
<p>The following formats for the <code>source</code> Url are available:</p>
<ul>
<li>No &quot;scheme&quot; in the URI --&gt; <code>file:</code> is assumed. If the path starts with <code>/</code> then an absolute path is used. If
the path does not start with <code>/</code> then the path is assumed to be relative to the location of the file referring to it.</li>
<li><code>file:</code> scheme --&gt; look for process definition file on the local file system</li>
<li><code>http:</code> or <code>https:</code> scheme --&gt; look for process definition file on a the web</li>
<li><code>lib:</code> --&gt; look for process in a Library that is loaded by the runtime. See <a href="docs/describing/flow_libraries.html">flow libraries</a> for 
more details on how this Url is used to find the process definition file provided by the library.</li>
<li><code>context:</code> --&gt; a reference to a function in the context, provided by the runner application. See <a href="docs/describing/context_functions.html">context 
functions</a> for more details on how the process definition file is used.</li>
</ul>
<h4 id="file-source"><a class="header" href="#file-source">File source</a></h4>
<p>This is the case when no scheme or the <code>file://</code> scheme is used in the <code>source</code> Url.
The process definition file is in the same file system as the file referencing it.</p>
<ul>
<li>in the flow's directories, using relative file paths 
<ul>
<li>e.g. <code>source = &quot;my_function&quot;</code></li>
<li>e.g. <code>source = &quot;my_flow&quot;</code></li>
<li>e.g. <code>source = &quot;subdir/my_other_function&quot;</code></li>
<li>e.g. <code>source = &quot;subdir/my_other_process&quot;</code></li>
</ul>
</li>
<li>in a different flow's directories, using relative file paths
<ul>
<li>e.g. <code>source = &quot;../other_flow/other_function&quot;</code></li>
<li>e.g. <code>source = &quot;../other_flow/other_flow&quot;</code></li>
</ul>
</li>
<li>elsewhere in the local file system, using absolute paths
<ul>
<li>e.g. <code>source = &quot;/root/other_directory/other_function&quot;</code></li>
<li>e.g. <code>source = &quot;/root/other_directory/other_flow&quot;</code></li>
</ul>
</li>
</ul>
<h4 id="web-source"><a class="header" href="#web-source">Web Source</a></h4>
<p>When the <code>http</code> or <code>https</code> Url scheme is used for <code>source</code> the process definition file is loaded via http request
to the specified location.</p>
<ul>
<li>e.g. <code>source = &quot;http://my_flow_server.com/folder/function&quot;</code></li>
<li>e.g. <code>source = &quot;https://my_secure_flow_server.com/folder/flow&quot;</code></li>
</ul>
<h3 id="initializing-an-input-in-a-reference"><a class="header" href="#initializing-an-input-in-a-reference">Initializing an input in a reference</a></h3>
<p>Inputs of a referenced process may be initialized, in one of two ways:</p>
<ul>
<li><code>once</code> - the value is inserted into the input just once on startup and there after it will remain empty if a 
value is not sent to it from a Process.</li>
<li><code>always</code> - the value will be inserted into the input each time after the process runs.</li>
</ul>
<p>Example, initializing the <code>add</code> function's <code>i1</code> and <code>2</code> inputs to 0 and 1 respectively, just once at the start
of the flow's execution.</p>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/math/add&quot;
input.i1 = { once =  0 }
input.i2 = { once =  1 }
</code></pre>
<p>Example, initializing the <code>add</code> function's <code>i1</code> input to 1 every time it runs. The other input is free to be
used in connections and this effectively makes this an &quot;increment&quot; function that adds one to any value sent to it
on the <code>i2</code> input.</p>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/math/add&quot;
input.i1 = { always =  1 }
</code></pre>
<h4 id="initializing-the-default-input"><a class="header" href="#initializing-the-default-input">Initializing the default input</a></h4>
<p>When a process only has one input, and it is not named, then you can refer to it by the name <code>default</code> for the
purposes of specifying an initializer</p>
<p>Example, initializing the sole input of <code>stdout</code> context function with the string &quot;Hello World&quot; just once at
the start of flow execution:</p>
<pre><code class="language-toml">[[process]]
source = &quot;context://stdio/stdout&quot;
input.default = {once = &quot;Hello World!&quot;}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="function-definitions"><a class="header" href="#function-definitions">Function Definitions</a></h2>
<p>A function is defined in a definition file that should be alongside the function's implementation files (see later)</p>
<h3 id="function-definition-fields"><a class="header" href="#function-definition-fields">Function Definition Fields</a></h3>
<ul>
<li><code>function</code>   - Declares this files is defining a function and defines the name of the function.
This is required to link the definition with the implementation and allow the flow compiler to be able to find
the implementation of the function and to include it in the generated project. <code>name</code> must match exactly the name
of the object implemented.</li>
<li><code>source</code> - the file name of the file implementing the function, relative to the location of the definition file</li>
<li><code>docs</code> - a markdown file documenting the function, relative to the location of the definition file</li>
<li><code>input</code>  - zero (for impure)|one (for pure) or more inputs (as per <a href="docs/describing/ios.html">IO</a>)</li>
<li><code>output</code> - zero (for impure)|one (for pure) or more outputs (as per <a href="docs/describing/ios.html">IO</a>)</li>
<li><code>impure</code> - optional field to define an impure function</li>
</ul>
<h3 id="types-of-function-definitions"><a class="header" href="#types-of-function-definitions">Types of Function Definitions</a></h3>
<p>Functions may reside in one of three locations:</p>
<ul>
<li>A <code>context function</code> provided by a flow running applications, as part of a set of functions it provides to flows
to allow them to interact with the environment, user etc. E.g. <code>readline</code> to read a line of text from STDIN.</li>
<li>A <code>library function</code> provided by a flow library, that a flow can reference and then use to help define the overall
flow functionality. E.g. <code>add</code> from the <code>flowstdlib</code> library to add two numbers together.</li>
<li>A <code>provided function</code> where the function's definition and implementation are provided within
the flow hierarchy. As such they cannot be easily re-used by other flows.</li>
</ul>
<h3 id="impure-or-context-functions"><a class="header" href="#impure-or-context-functions"><code>Impure</code> (or <code>context</code>) functions</a></h3>
<p>An impure function is a a function that has just a source of data (e.g. <code>stdin</code> that interacts with the execution 
environment to get the data and then outputs it) or just a sink of data (e.g. <code>stdout</code> that takes 
an input and passes it to the execution environment and produces no output in the flow).</p>
<p>The output of an impure function is not deterministic based just on the inputs provided to it but depends on the
system or the user using it.
It may have side-effects on the system, such as outputting a string or modifying a file.</p>
<p>In <code>flow</code> these are referred to as <code>context functions</code>because they interact with (and are provided by) the
execution context where the flow is run. For more details see <a href="docs/describing/context_functions.html">context functions</a></p>
<p>Impure functions should <em>only</em> be defined as part of a set of <code>context functions</code>, not as a function in a 
library nor as a provided function within a flow.</p>
<p>Impure functions should declare themselves impure in their definition file using the optional <code>impure</code> field.</p>
<p>Example, the <code>stdin</code> context function declares itself impure</p>
<pre><code>function = &quot;stdin&quot;
source = &quot;stdin.rs&quot;
docs = &quot;stdin.md&quot;
impure = true
...
</code></pre>
<h3 id="pure-functions-1"><a class="header" href="#pure-functions-1"><code>Pure</code> functions</a></h3>
<p>Functions that are used within a flow (whether provided by the flow itself or from a library) must be <code>pure</code>
(not depend on input other than the provided input values nor have no side-effects in the system) and have 
at least one input and one output.</p>
<ul>
<li>If they had no input, there would be no way to send data to it and it would be useless</li>
<li>If it had no output, then it would not be able to send data to other functions and would also be useless</li>
</ul>
<p>Thus, such a <code>pure</code> function can be run anytime, anywhere, with the same input and it will produce the same
output.</p>
<h3 id="function-execution"><a class="header" href="#function-execution">Function execution</a></h3>
<p>Functions are made available to run when a set of inputs is available on all of its inputs. Then a job is 
created containing one set of input values (a value taken from each of it's inputs) and sent for execution.
Execution may produce an output value, which using the connections defined, will be passed on to the connected
input of one or more other functions in the function graph. That in turn may cause that other function to run
and so on and so forth, until no function can be found available to run.</p>
<h3 id="default-inputs-and-outputs-1"><a class="header" href="#default-inputs-and-outputs-1">Default inputs and outputs</a></h3>
<p>If a function only has one input or one output, then naming that input/output is optional. 
If not named, it is referred to as the default input. Connections may connect data to/from this input/output just
by referencing the function.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>By default flow supports JSON types:</p>
<ul>
<li><code>null</code></li>
<li><code>boolean</code></li>
<li><code>object</code></li>
<li><code>array</code></li>
<li><code>number</code></li>
<li><code>string</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="connection"><a class="header" href="#connection">Connection</a></h2>
<p>Connections connect a source of data (via an IO Reference) to a sink of data (via an IO Reference) 
of a compatible <a href="docs/describing/types.html">type</a> within a flow.</p>
<ul>
<li><code>name</code> (Optional) - an Optional name for the flow. This can be used to help in debugging flows</li>
<li><code>from</code> = IO Reference to the data source that this connection comes from</li>
<li><code>to</code> = IO Reference to a data sink that this connection goes to</li>
</ul>
<h3 id="connections-at-multiple-level-in-flow-hierarchy"><a class="header" href="#connections-at-multiple-level-in-flow-hierarchy">Connections at multiple level in flow hierarchy</a></h3>
<p>A flow is a hierarchy from the root flow down, including functions and sub-flows (collectively sub-processes).</p>
<p>Connections are defined within each flow or sub-flow from a source to a destination.</p>
<p>Within a flow sources include:</p>
<ul>
<li>an input of this flow</li>
<li>an output from one of the sub-processes</li>
</ul>
<p>and destinations include</p>
<ul>
<li>an input of one of the sub-processes</li>
<li>an output of this flow</li>
</ul>
<p>A connection may be defined with multiple destinations and/or there maybe multiple connections a one source or to a 
destination.</p>
<h3 id="connection-branching"><a class="header" href="#connection-branching">Connection &quot;branching&quot;</a></h3>
<p>Within a sub-flow there may exist a connection to one of it's outputs, as a destination.
At the next level up in the flow hierarchy that sub-flow output becomes a possible source for connections
defined at that level.</p>
<p>Thus a single connection originating at a single source in the sub-flow may &quot;branch&quot; into multiple connections, 
reaching multiple destinations.</p>
<h3 id="connection-feedback"><a class="header" href="#connection-feedback">Connection feedback</a></h3>
<p>It is possible to make a connection from a process's output back to one of its inputs. This is useful for
looping, recursion, accumulation etc as described later in <a href="docs/describing/programming_methods.html">programming methods</a></p>
<h3 id="connection-from-input-values"><a class="header" href="#connection-from-input-values">Connection <em>from</em> input values</a></h3>
<p>The input values used in an execution are made available at the output alongside the output value calculated,
<em>when completes execution</em>. Thus a connection can be formed from this input value and the value is
sent via connections when the function completes, similar to the output value. It is also possible to
feedback this input value back to the same or different input for use in recursion. An example of this can be
seen in the <a href="docs/describing/../../flowsamples/fibonacci/root.toml">fibonacci example</a> flow definition.</p>
<pre><code># Loop back the input value #2 from this calculation, to be the input to input #1 on the next iteration
[[connection]]
from = &quot;add/i2&quot;
to = &quot;add/i1&quot;
</code></pre>
<h3 id="connection-gathering-and-collapsing"><a class="header" href="#connection-gathering-and-collapsing">Connection Gathering and Collapsing</a></h3>
<p>When a flow is compiled, sources of data (function outputs) are followed through the through layers of 
sub-flows/super-flow definition of the flow hierarchy and the resulting &quot;tree&quot; of connections to be eventually 
connected (possibly branching to become multiple connections) to destination(s).</p>
<p>The chain of connections involved in connecting a source to each of the destinations is 
&quot;collapsed&quot; as part of the compilation process, to leave a single connection from the source to each of the destinations. </p>
<h3 id="connection-optimizing"><a class="header" href="#connection-optimizing">Connection Optimizing</a></h3>
<p>Thru flow re-use, come connections may end up not reaching any destination. The compiler optimizes these connections
away by dropping them.</p>
<p>If in the process of dropping dead connections a function ends up not having any output and/or input (for &quot;pure
functions) it maybe removed, and an error or warning reported by the compiler.</p>
<h3 id="io-references"><a class="header" href="#io-references">IO References</a></h3>
<p>An IO Reference uniquely identifies an Input/Data-source (flow/function) or an Output/Data-sink in the flow
hierarchy.</p>
<p>If any flows or functions defined in other files are referenced with an alias, then it should be
used in the IO references to inputs or outputs of that referenced flow/function.</p>
<p>Thus valid IO reference formats to use in connections are:</p>
<h4 id="data-sinks"><a class="header" href="#data-sinks">Data sinks</a></h4>
<ul>
<li><code>input/{input_name}</code> (where input is a keyword and thus a sub-flow cannot be named <code>input</code> or <code>output</code>)</li>
<li><code>{sub_process_name}/{output_name}</code> or <code>{sub_process}</code> for the default output</li>
</ul>
<p>Where <code>sub_process_name</code> is a <code>process</code> referenced in this flow, and maybe a function or a sub-flow.
The reference use the process's name (if the process was not given an alias when referenced) or it's alias.</p>
<h4 id="data-sinks-1"><a class="header" href="#data-sinks-1">Data sinks</a></h4>
<ul>
<li><code>output/{output_name}</code> (where output is a keyword and thus a sub-flow cannot be named <code>input</code> or <code>output</code>)</li>
<li><code>{sub_process_name}/{input_name}</code> or <code>{sub_process}</code> for the default input</li>
</ul>
<h3 id="selecting-parts-of-a-connections-value"><a class="header" href="#selecting-parts-of-a-connections-value">Selecting parts of a connection's value</a></h3>
<p>A connection can select to &quot;connect&quot; only part of the data values passed on the source of the connection.
See below <a href="docs/describing/connections.html#selecting-sub-structures-of-an-output">Selecting sub-structures of an output</a> for more details.</p>
<h3 id="run-time-semantics"><a class="header" href="#run-time-semantics">Run-time Semantics</a></h3>
<p>An input IO can be connected to multiple outputs, via multiple connections. </p>
<p>An output IO can be connected to multiple inputs on other flows or functions via multiple connections.</p>
<p>When the data is produced on the output by a function the data is copied to each destination function
using all the connections that exists from that output.</p>
<p>Data can be buffered at each input of a function.</p>
<p>The order of data arrival at a functions input is the order of creation of jobs executed by that function.
However, that does not guarantee order of completion of the job.</p>
<p>A function cannot run until data is available on all inputs.</p>
<p>Loops are permitted from an output to an input, and are used as a feature to achieve certain behaviours.</p>
<p>When a function runs it produces a result that can contain an output. The result also contains all the 
inputs used to produce any output. Thus input values can be reused by connecting from this &quot;output input-value&quot;
in connections to other processes, or looped back to an input of the same function.</p>
<p>Example, the <a href="docs/describing/../../flowsamples/fibonacci/root.toml">fibonacci example</a> uses this to define recursion.</p>
<pre><code>...
# Loop back the input value #2 from this calculation, to be the input to input #1 on the next iteration
[[connection]]
from = &quot;add/i2&quot;
to = &quot;add/i1&quot;
...
</code></pre>
<h3 id="type-match"><a class="header" href="#type-match">Type Match</a></h3>
<p>For a connection to be valid and used in execution of a flow, the data source must be found,
the data sink must be found and the two must be of compatible DataTypes.</p>
<p>If those conditions are not met, then a connection will be dropped (with an error message output)
and the flow will attempted to be built and executed without it.</p>
<p>By not specifying the data type on intermediary connections thru the flow hierarchy, the flow author can enable
connections that are not constrained by the intermediate inputs/outputs used and those types are not need to be 
known when the flow is being authored. In this case the type check will pass on the intermediate connections to 
those &quot;generic&quot; inputs our output.</p>
<p>However, once the connection chain is collapsed down to one end-to-end connection, the source and destination 
types must also pass the type check. This includes intermediate connections that may select part of the value.</p>
<p>Example</p>
<ul>
<li>Subflow 1 has a connection: A function <code>series</code> with default output Array/Number --&gt; Generic output of the subflow
<ul>
<li>The destination of the connection is generic and so the intermediate type check passes</li>
</ul>
</li>
<li>Root flow (which contains Subflow 1) as a connection: Generic output of the subflow --&gt; Function <code>add</code> input <code>i1</code>
(which has a data type <code>Number</code>) that includes selection of an element of the array of numbers <code>/1</code>
<ul>
<li>The source is generic, so the intermediate type check passes</li>
</ul>
</li>
<li>A connection chain is built from the <code>series</code> output thru the intermediate connection to the <code>add</code> function input <code>i1</code></li>
<li>The connection chain is collapsed to a connection from the Array element of index 1 of the <code>series</code> function's 
output to the <code>add</code> functions input <code>i1</code></li>
<li>The <code>from</code> and <code>to</code>types of this collapsed connection are both <code>Number</code> and so the type check passes</li>
</ul>
<h3 id="runtime-type-conversion-of-compatible-types"><a class="header" href="#runtime-type-conversion-of-compatible-types">Runtime type conversion of Compatible Types</a></h3>
<p>The flow runtime library implements some type conversions during flow execution, permitting non-identical
types from an output and input to be connected by the compiler, knowing the runtime will handle it.</p>
<p>These are know as <code>compatible types</code>. At the moment the following conversions are implemented but more 
maybe added over time:</p>
<h4 id="matching-types"><a class="header" href="#matching-types">Matching Types</a></h4>
<ul>
<li>Type 'T' --&gt; Type 'T'. No conversion required.</li>
</ul>
<h4 id="generics"><a class="header" href="#generics">Generics</a></h4>
<ul>
<li>Generic type --&gt; any input. This assumes the input will check the type and handle appropriately.</li>
<li>Array/Generic type --&gt; any input. This assumes the input will check the type and handle appropriately.</li>
<li>any output --&gt; Generic type. This assumes the input will check the type and handle appropriately.</li>
<li>any output --&gt; Array/Generic type. This assumes the input will check the type and handle appropriately.</li>
</ul>
<h4 id="array-deserialization"><a class="header" href="#array-deserialization">Array Deserialization</a></h4>
<ul>
<li>Array/'T' --&gt; 'T'. The runtime will &quot;deserialize&quot; the array and send it's elements one-by-one to the input.
<em>NOTE</em> that 'T' maybe any type, including an Array, which is just a special case.</li>
<li>Array/Array/'T' --&gt; 'T'. The runtime will &quot;deserialize&quot; the array of arrays and send elements one-by-one to the input</li>
</ul>
<h4 id="array-wrapping"><a class="header" href="#array-wrapping">Array Wrapping</a></h4>
<ul>
<li>'T' --&gt; Array/'T'. The runtime will take the value and wrap it in an array and send that one-element array to the 
input. Again, 'T' can be any type, including an Array.</li>
<li>'T' --&gt; Array/Array/'T'. The runtime will take the value and wrap it in an array in an array and send that 
one-element array of arrays to the input.</li>
</ul>
<h3 id="default-input-or-output"><a class="header" href="#default-input-or-output">Default input or output</a></h3>
<p>If a function only has one input or one output, then naming that input/output is optional.
If not names it is referred to as the default input. Connections may connect data to/from this input just
by referencing the function.</p>
<p>Example, the <code>stdout</code> context function only has one input and it is not named</p>
<pre><code>function = &quot;stdout&quot;
source = &quot;stdout.rs&quot;
docs = &quot;stdout.md&quot;
impure = true

[[input]]
</code></pre>
<p>and a connection to it can be defined thus:</p>
<pre><code>[[connection]]
from = &quot;add&quot;
to = &quot;stdout&quot;
</code></pre>
<h3 id="named-inputs"><a class="header" href="#named-inputs">Named inputs</a></h3>
<p>If an input is defined with a name, then connections to it should include the function name and the input name
to define which input is being used.</p>
<p>Example</p>
<pre><code>[[connection]]
from = &quot;add&quot;
to = &quot;add/i2&quot;
</code></pre>
<h3 id="selecting-an-output"><a class="header" href="#selecting-an-output">Selecting an output</a></h3>
<p>When a function runs it produces a set of outputs, producing data on zero or more of it's outputs, all at once.</p>
<p>A connection can be formed from an output to another input by specifying the output's <code>route</code> as part of the 
<code>IO Reference</code> in the <code>from</code> field of the connection.</p>
<p>Example:</p>
<pre><code>[[connection]]
from = &quot;function_name/output_name&quot;
to = &quot;stdout&quot;
</code></pre>
<h3 id="selecting-sub-structures-of-an-output"><a class="header" href="#selecting-sub-structures-of-an-output">Selecting sub-structures of an output</a></h3>
<p>As described in <a href="docs/describing/types.html">types</a>, flow supports Json data types. This includes two &quot;container types&quot;, namely:
&quot;object&quot; (a Map) and &quot;array&quot;.</p>
<p>If an output produces an object, a connection can be formed from an entry of the map (not the entire map) to a
destination input. This allows (say) connecting a function that produces a Map of strings to another function
that accepts a string. This is done extending the <code>route</code> used in the <code>IO Reference</code> of the <code>connection</code> with 
the output name (to select the output) and the key of the map entry (to select just that map entry).</p>
<p>Example: function called &quot;function&quot; has an output named &quot;output&quot; that produces a Map of strings. 
One of those Map entries has the key &quot;key&quot;. Then the string value associated with that key is used in the 
connection.</p>
<pre><code>[[connection]]
from = &quot;function/output/key&quot;
to = &quot;stdout&quot;
</code></pre>
<p>Similarly, if the output is an array of values, a single element from the array can be specified in the <code>connection</code>
using a numeric subscript.</p>
<p>Example: function called &quot;function&quot; has an output named &quot;output&quot; that produces an array of strings.
Then a single string from the array can be sent to a destination input thus:</p>
<pre><code>[[connection]]
from = &quot;function/output/1&quot;
to = &quot;stdout&quot;
</code></pre>
<p>If a function runs and produces an output which does not contain the sub-structure selected by a connection, 
for the purpose of the destination of that connection it is just as if the output was not produced, 
or the function had not run. Thus, no value will arrive at the destination function and it will not run.</p>
<h3 id="connecting-to-multiple-destinations"><a class="header" href="#connecting-to-multiple-destinations">Connecting to multiple destinations</a></h3>
<p>A single output can be connected to multiple destinations by creating multiple connections referencing the output.
But, to make it easier (less typing) to connect an output to multiple destinations the <code>[[connection]]</code> format
permits specifying more than one <code>to = &quot;destination&quot;</code>.</p>
<p>Example</p>
<pre><code>[[connection]]
from = &quot;output&quot;
to = [&quot;destination&quot;, &quot;destination2&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flow-libraries"><a class="header" href="#flow-libraries">Flow Libraries</a></h2>
<p>Libraries can provide functions (definition and implementation) and flows (definition) that can be re-used by other 
flows.</p>
<p>An example library is the <code>flowstdlib</code> library, but others can be created and shared by developers.</p>
<h3 id="library-structure"><a class="header" href="#library-structure">Library structure</a></h3>
<p>A flow library's structure is upto the developer to determine, starting with a <code>src</code> subdirectory, with optional 
sub-directories for modules, and sub-modules.</p>
<h4 id="native-crate-structure"><a class="header" href="#native-crate-structure">Native crate structure</a></h4>
<p>In order to support native linking of lib, it must be a valid rust crate and so a <code>Cargo.toml</code> file in the source
that references a <code>lib.rs</code> file, that in turn references <code>mod.rs</code> files in sub folder that reference the sources, so 
that it is all included into the crate when compiled. </p>
<p>Example</p>
<pre><code>[lib]
name = &quot;flowstdlib&quot;
path = &quot;src/lib.rs&quot;
</code></pre>
<h4 id="parallel-wasm-crate-structure---wasm-library-build-speed-up"><a class="header" href="#parallel-wasm-crate-structure---wasm-library-build-speed-up">Parallel WASM crate structure - WASM library build speed-up</a></h4>
<p>Each function (see below) contains it's own <code>Cargo.toml</code> used to compile it to WASM. If left like this, then
each function will re-compile all of the source dependencies, even if many of the dependencies are shared across
all the functions, making the library compile to WASM very slow.</p>
<p>To speed up library builds, a solution (&quot;hack&quot;) is used. A cargo workspace is defined in parallel with the Native 
crate mentioned above, with it's root workspace <a href="docs/describing/../../flowstdlib/src/Cargo.toml">Cargo.toml</a> in the {lib_name}/src/
folder. This workspace includes as members references to all the <code>Cargo.toml</code> files of the functions (see below).
Thus when any of them are compiled they share a single target directory and the common dependencies are only
compiled once</p>
<h4 id="including-a-flow"><a class="header" href="#including-a-flow">Including a flow</a></h4>
<p>Flow definition files may reside at any level. Example, the <a href="docs/describing/../../flowstdlib/src/math/sequence.toml">sequence</a> flow definition 
in the <code>math</code> module of the <code>flowstdlib</code> library.</p>
<p>Alongside the flow definition a documentation Markdown file (with <code>.md</code> extension) can be included. It should be
referenced in the flow definition file using the <code>docs</code> field (e.g. <code>docs = &quot;sequence.md&quot;</code>).</p>
<h4 id="including-a-function"><a class="header" href="#including-a-function">Including a function</a></h4>
<p>Each function should have a subdirectory named after function (<code>{function_name}</code>), which should include:</p>
<ul>
<li><code>Cargo.toml</code> - build file for rust implementations</li>
<li><code>{function_name}.toml</code> - function definition file. It should include these fields
<ul>
<li><code>type = &quot;rust&quot;</code> - type is obligatory and &quot;rust&quot; is the only type currently implemented</li>
<li><code>function = &quot;{function_name}&quot;</code> - obligatory </li>
<li><code>source = &quot;{function_name}.rs&quot;</code> - obligatory and file must exist. </li>
<li><code>docs = &quot;{function_name}.md&quot;</code> - optional documentation file that if referenced must exist</li>
</ul>
</li>
<li><code>{function_name}.md</code> - if references in function definition file then it will be used (copied to output)</li>
<li><code>{function_name}.rs</code> - referenced from function definition file. Must be valid rust and implement required traits</li>
</ul>
<h3 id="compiling-a-library"><a class="header" href="#compiling-a-library">Compiling a library</a></h3>
<p>Flow libraries can be compiled using the <code>flowc</code> flow compiler and its <code>-l, --lib</code> option. This will compiler
and/or copy all required files from the library source directory into a library directory structure (where
can be specified with the <code>-o, --output &lt;OUTPUT_DIR&gt;</code> option). This directory is a self-contained, portable
library. It can be packaged, moved, unpackaged and used elsewhere, providing it can be found by the compiler
and runtime (using <code>FLOW_LIB_PATH</code> env var and <code>-L, --libdir &lt;LIB_DIR|BASE_URL&gt;</code> options) when needed.</p>
<p>The output directory structure will have the same structure as the library source (subdirs for modules) and will
include:</p>
<ul>
<li><code>manifest.json</code> - Generated Library manifest, in the root of the directory structure</li>
<li><code>*.md</code> - Markdown source files copied into output directory corresponding to source directory</li>
<li><code>*.toml</code> - Flow and Function definition files copied into output directory corresponding to source directory</li>
<li><code>*.wasm</code> - Function WASM implementation compiled from supplied function source and copied into output 
directory corresponding to source directory</li>
<li><code>*.dot</code> - 'dot' (graphvis) format graph descriptions of any flows in the library source</li>
<li><code>*.dot.svg</code> - flow graphs rendered into SVG files from the corresponding 'dot' files. These can be referenced in 
doc files</li>
</ul>
<h3 id="lib-references"><a class="header" href="#lib-references">Lib References</a></h3>
<p>References to flows or functions are described in more detail in the <a href="docs/describing/process_references.html">process references</a>
section. Here we will focus on specifying the source for a process (flow or function) from a library using the &quot;lib://&quot;
Url format.</p>
<p>The process reference to refer to a library provided flow or function is of the form:
<code>lib://lib_name/path_to_flow_or_function</code></p>
<p>Breaking that down:</p>
<ul>
<li>&quot;lib://&quot; Url scheme identifies this reference as a reference to a library provided flow or function</li>
<li>&quot;lib_name&quot; (the hostname of the Url) is the name of the library</li>
<li>&quot;path_to_flow_or_function&quot; (the path of the Url) is the location <em>withing</em> the library where the flow or function 
resides.</li>
</ul>
<p>By not specifying a location (a file with <code>file://</code> or web resource with <code>http://</code> or <code>https://</code>) allows the system
to load the actual library with it's definitions and implementation from different places in different <code>flow</code> 
installations thus flows that use library functions are portable, providing the library is present and can be found 
wherever it is being run.</p>
<p>The <code>flowrlib</code> runtime library accepts a &quot;search path&quot; where it should look for the library (using the library's
name &quot;lib_name&quot; from the Url)</p>
<p>Different flow runners (e.g. <code>flowr</code> or <code>flowrex</code> are included examples here but others can be written) can provide
different ways to provide entries in the search path. Below we describe how <code>flowr</code> and <code>flowrex</code> do this.</p>
<h3 id="configuring-the-library-search-path"><a class="header" href="#configuring-the-library-search-path">Configuring the Library Search Path</a></h3>
<p>The library search path is initialized from the contents of the <code>$FLOW_LIB_PATH</code> environment variable
(if it is defined).
This path maybe augmented by supplying additional directories or URLs to search using one
or more instances of the <code>-L</code> command line option.</p>
<h3 id="finding-the-references-lib-process"><a class="header" href="#finding-the-references-lib-process">Finding the references lib process</a></h3>
<p>The algorithm used to find files via process references is described in more detail in the 
<a href="docs/describing/process_references.html">process references</a> section. An example of how a library function is found is shown below.</p>
<p>A process reference exists in a flow with <code>source = &quot;flowstdlib://math/add&quot;</code></p>
<ul>
<li>Library name = <code>flowstdlib</code></li>
<li>Function path within the library = <code>math/add</code></li>
</ul>
<p>All the directories in the search path are searched for a top-level sub-directory that matches the library name.</p>
<p>If a directory matching the library name is found, the path to the process within the library is used to try and
find the process definition file.</p>
<p>For example, if <code>FLOW_LIB_PATH</code> environment variable is defined thus:</p>
<ul>
<li><code>export FLOW_LIB_PATH=/Users/me/workspace/flow</code></li>
</ul>
<p>And the flow references a process thus:</p>
<pre><code class="language-toml">[[process]]
source = &quot;flowstdlib://math/add&quot;
</code></pre>
<p>Then the directory <code>/Users/me/workspace/flow/flowstdlib</code> is looked for.</p>
<p>If that directory is found, then the process path within the library <code>stdio/stdin</code> is used to create the full path
to the process definition file is <code>/Users/me/workspace/flow/flowstdlib/math/add</code>.</p>
<p>(refer to the full algorithm in <a href="docs/describing/process_references.html">process references</a>)</p>
<p>If the file <code>/Users/me/workspace/flow/flowstdlib/math/add.toml</code> exists then it is parsed and made available to the flow
for use in connections.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="context-functions"><a class="header" href="#context-functions">Context Functions</a></h2>
<p>Each flow runner application can provide a set of functions (referred to as <code>context functions</code>) to flows for 
interacting with the execution environment.</p>
<p>They are identified by a flow defining a process reference that uses the <code>context://</code> Url scheme.
(see <a href="docs/describing/process_references.html">process references</a> for more details).</p>
<p>In order to compile a flow the compiler must be able to find the definition of the function.</p>
<p>In order to execute a flow the flow runner must either have an embedded implementation of the function or
know how to load one.</p>
<p>Different runtimes may provide different functions, and thus it is not guaranteed that a function is present 
at runtime.</p>
<h3 id="completion-of-functions"><a class="header" href="#completion-of-functions">Completion of Functions</a></h3>
<p>Normal &quot;pure&quot; functions can be executed any number of times as their output depends only on the inputs and the
(unchanging) implementation. They can be run any time a set of inputs is available.</p>
<p>However, a context function may have a natural limit to the number of times it can be ran during the execution of
a flow using it. An example would be a function that reads a line of text from a file. It can be ran as many times
as there are lines of text in the file, then it will return End-Of-File and a flag to indicate to the flow runtime
that it has &quot;completed&quot; should not be invoked again.</p>
<p>If this was not done, as the function has no inputs, it would always be available to run, and be executed 
indefinitely, just to return EOF each time. </p>
<p>For this reason, each time a function is run, it returns a &quot;run me again&quot; flag that the runtime uses to determine
if it has &quot;completed&quot; or not. If it returns true, then the function is put into the &quot;completed&quot; state and it will
never be run again (during that flow's execution)</p>
<h3 id="specifying-the-context-root"><a class="header" href="#specifying-the-context-root">Specifying the Context Root</a></h3>
<p>At compile time the compiled must know which functions are available and their definitions.</p>
<p>Since it is the flow runner that provides the implementations and knows their definitions, it must make these
discoverable and parseable by the compiler as a set of function definition files.</p>
<p>This is done by specifying to the <code>flowc</code> compiled what is called the <code>context root</code> or the root folder of 
where the targeted runtime's context functions reside.</p>
<h3 id="context-function-process-references"><a class="header" href="#context-function-process-references">Context Function Process References</a></h3>
<p>A reference to a <code>context function</code> process (in this case it is always a function) such as STDOUT is of the form:</p>
<pre><code>[[process]]
source = &quot;context://stdio/stdout&quot;
</code></pre>
<p>The <code>context://</code> Url scheme identifies it is a <code>context function</code> and it's definition should be sought below
the <code>Context Root</code>. The rest of the Url specifies the location under the <code>Context Root</code> directory (once found).</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>The <code>flow</code> project directory structure is used in this example, with <code>flow</code> located at <code>/Users/me/flow</code> and 
<code>flow</code> in the users <code>$PATH</code>.</p>
<p>The fibonacci sample flow is thus found in the <code>/Users/me/flow/flowsamples/fibonacci</code> directory.</p>
<p>The <code>flowr</code> flow runner directory is thus at <code>/Users/me/flow/flowr</code>. Within that folder flowr provides a set of 
context function definitions for a Command Line Interface (CLI) implementation in the <code>src/cli</code> sub-directory.</p>
<p>If in the root directory of the <code>flow</code> project, using relative paths, the sample flow can be compiled and 
run using the <code>-C, --context_root &lt;CONTEXT_DIRECTORY&gt;</code> option to <code>flowc</code>:</p>
<pre><code>&gt; flowc -C flowr/src/cli flowsamples/fibonacci
</code></pre>
<p>The <code>flowc</code> compiler sees the <code>&quot;context://stdio/stdout&quot;</code> reference. It has been told that the <code>Context Root</code> is
at <code>flowr/src/cli</code> so it searches for (and finds) a function definition file at <code>flowr/src/cli/stdio/stdout/stdout.toml</code>
using the alrgorithm described in <a href="docs/describing/process_references.html">process references</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="provided-functions"><a class="header" href="#provided-functions">Provided Functions</a></h2>
<p>As described previously, flows can use <code>provided functions</code> provided by the flow runner app (e.g. <code>flowr</code>)
and by flow libraries.</p>
<p>However, a flow can also provide its own functions (a definition, for the compiler, and an implementation, 
for the runtime).</p>
<p>The <a href="docs/describing/process_references.html">process references</a> section describes the algorithm for finding the function's files 
(definition and implementation) using relative paths within a flow file hierarchy.</p>
<p>Using relative paths means that flows are &quot;encapsulated&quot; and portable (by location) as they can be moved
between directories, files systems and systems/nodes and the relative locations of the provided functions allow 
them to still be found and the flow compiled and ran.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>The <code>flowsamples</code> crates has two samples that provide functions as part of the flow:</p>
<ul>
<li><a href="docs/describing/../../flowsamples/reverse-echo/DESCRIPTION.html">Reverse Echo</a> in the folder <code>flowsamples/reverse-echo</code> - a
simple sample that provides a function to reverse a string</li>
<li><a href="docs/describing/../../flowsamples/mandlebrot/DESCRIPTION.html">Mandlebrot</a> in the folder <code>flowsamples/mandlebrot</code> - provides
two functions:
<ul>
<li><code>pixel_to_point</code> to do conversions from pixels to points in 2D imaginary
coordinates space</li>
<li><code>escapes</code> to calculate the value of a point in the mandlebrot set</li>
</ul>
</li>
</ul>
<h3 id="what-a-provided-function-has-to-provide"><a class="header" href="#what-a-provided-function-has-to-provide">What a provided function has to provide</a></h3>
<p>In order to provide a function as part of a flow the developer must provide:</p>
<h4 id="function-definition-file"><a class="header" href="#function-definition-file">Function definition file</a></h4>
<p>Definition of the function in a TOML file.<br />
Example <a href="docs/describing/../../flowsamples/mandlebrot/escapes/escapes.toml">escapes.toml</a><br />
The same as any other function definition it must define:</p>
<ul>
<li><code>function</code> - field to show this is a function definition file and provide the function's name </li>
<li><code>source</code> - the name of the implementation file (relative path to this file)</li>
<li><code>type</code> - to define what type of implementation is provided (<code>&quot;rust&quot;</code> is the only supported value at this time)</li>
<li><code>input</code>- the function's inputs - as described in <a href="docs/describing/ios.html">IOs</a></li>
<li><code>output</code>- the function's outputs - as described in <a href="docs/describing/ios.html">IOs</a></li>
<li><code>docs</code> - Documentation markdown file (relative path)<br />
Example <a href="docs/describing/../../flowsamples/mandlebrot/escapes/escapes.html">escapes.md</a></li>
</ul>
<h4 id="implementation"><a class="header" href="#implementation">Implementation</a></h4>
<p>Code that implements the function of the type specified by <code>type</code> in the file specified by <code>source</code>.<br />
Example: <a href="docs/describing/../../flowsamples/mandlebrot/escapes/escapes.rs">escapes.rs</a></p>
<p>This may optionally include tests, that will be compiled and run natively.</p>
<h4 id="build-file"><a class="header" href="#build-file">Build file</a></h4>
<p>In the case of the <code>rust</code> type (the only type implemented!), a <code>Cargo.toml</code> file that is used to compile 
the function's implementation to WASM as a stand-along project. </p>
<h3 id="how-are-provided-function-implementations-loaded-and-ran"><a class="header" href="#how-are-provided-function-implementations-loaded-and-ran">How are provided function implementations loaded and ran</a></h3>
<p>If the flow running app (using the <code>flowrlib</code>library`) is statically linked, how can it load and then run the
provided implementation?</p>
<p>This is done by compiling the provided implementation to WebAssembly, using the provided build file. The .wasm
byte code file is generated when the flow is compiled and then loaded when the flow is loaded by <code>flowrlib</code></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="programming-methods"><a class="header" href="#programming-methods">Programming Methods</a></h2>
<p><code>flow</code> provides the following facilities to help programmers create flows:</p>
<h3 id="encapsulation-1"><a class="header" href="#encapsulation-1">Encapsulation</a></h3>
<p>Functionality can be encapsulated within a function at the lowest level by implementing it in code, defining
the function via a function definition file with it's inputs and outputs and describing the functionality 
provided by it in an associated markdown file.</p>
<p>Sets of functions, combined together to provide some defined functionality, can be grouped together and connected
in a graph in a flow, described in a flow definition file. This &quot;flows&quot;'s functionality can be defined via it's inputs
and outputs just like a function, and its functionality described in an associated markdown file.</p>
<p>Flow definitions in turn can reference and incorporate other flows, alongside functions, until the desired 
functionality is reached.</p>
<p>Thus functionality is encapsulated via a &quot;process&quot; definition file, where a &quot;process&quot; can be defined as a function or
a flow.</p>
<p>The mechanism to reference a process in a flow definition file is common for both types, and in fact the flow does
not &quot;know&quot; if the process referenced is implemented as a function or a flow. At a later date the functionality of 
the sub-process should be able to be changed from being a function to a flow (or vice versa) with no semantic difference
and no required change on the program and no impact to its execution result, within the limits of <a href="docs/describing/programming_methods.html#determinism-and-order">determinism and
concurrency</a>.</p>
<h3 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h3>
<p>Jobs, consisting of a set of input values, for execution by a function's implementation are created and dispatched
while inputs values are available to form them.</p>
<p>Two jobs for the same function are independent of each other. They maybe dispatched in one order, executed 
independently by the same or different executor, on the same or different machine, with the same or different CPU
architecture, and completed in a different order before their results are sent on to the destination input.</p>
<h3 id="determinism-and-order"><a class="header" href="#determinism-and-order">Determinism and Order</a></h3>
<p>The order of completion of jobs is not guaranteed to match the order of job creation. The order of a flows output is
determined by the logic of the flow itself, preventing, for example, that one value is calculated and results in
some change to the context before another one.</p>
<p>Examples of ways to create determinism are:</p>
<ul>
<li><a href="docs/describing/../../flowsamples/fibonacci/root.toml">fibonacci example</a> use of a feedback connection so that one value is used
in the calculation of the next value, thus guaranteeing the order of the series.</li>
<li><a href="docs/describing/../../flowsamples/sequence/root.toml">sequence example</a> use of a &quot;data flow control&quot; function (<code>join</code>) to ensure
that a string is not sent to the <code>stdout</code> function until a specific condition (<code>end-of-sequence</code>) is met.
<pre><code># Output a string to show we're done when the Sequence ends
[[process]]
source = &quot;lib://flowstdlib/control/join&quot;
input.data = {once =  &quot;Sequence done&quot;}
</code></pre>
</li>
</ul>
<p>In imperative, procedural programming we often either assume, or can rely on order, such as the order of execution
of statements within a for loop. But with <code>flow</code> and its focus on concurrency this is much less so. A series of jobs
(similar to the for loop example) to calculate a number of values, but they maybe all generated at once (or soon
after each other) and executed in parallel, with the calculations completing out of order.</p>
<p>Also, in flow libraries, such as <code>flowstdlib</code>, some functions are written differently from what you might expect,
don't assume order, and the results maybe different from what you expect. This is reflected in the naming of functions
also, such as <code>sequence</code> that is named carefully to communicate that the values are generated in a specific order.
The <code>range</code> function does not guarantee order, only that all the numbers in the range will be output.
This it may generate the numbers in the range out of order, unlike what one would expect from a procedural language.</p>
<h3 id="re-use"><a class="header" href="#re-use">Re-use</a></h3>
<p><code>flow</code> provides a number of mechanisms to help re-use, namely:</p>
<ul>
<li>definition and implementation of a function once, and then be able to incorporate it into any number of flows later
via a <a href="docs/describing/process_references.html">process reference</a></li>
<li>definition of a flow, combining sub-flows and/or functions, into a flow and then be able to incorporate it into any 
number of flows later via a <a href="docs/describing/process_references.html">process reference</a></li>
<li>definition of portable libraries containing flows and/or functions that can be shared between programmers and
incorporate it into any number of flows later via <a href="docs/describing/process_references.html">process references</a></li>
</ul>
<h3 id="connection-branching-1"><a class="header" href="#connection-branching-1">Connection &quot;branching&quot;</a></h3>
<p>As described in more detail in <a href="docs/describing/connections.html">connections</a>, a connection within a re-used flow to one of its
outputs can be &quot;branched&quot; into multiple connections to multiple destinations when the flow is compiled, without 
altering the definition of the original flow.</p>
<h3 id="control-flow-via-data-flow"><a class="header" href="#control-flow-via-data-flow">Control flow via Data flow</a></h3>
<p>In <code>flow</code>, everything is dataflow, and dataflow is everything. There are no other mechanisms to produce values,
or coordinate activity. There are no loops, if-then-else or other logic control mechanisms.</p>
<p>What there is (in the <code>control</code> module of the <code>flowstdlib</code> library, and you can add others) are a series of functions 
that control the flow of data.
These are functions such as:</p>
<ul>
<li><a href="docs/describing/../../flowstdlib/src/control/compare_switch/compare_switch.html">compare_switch</a></li>
<li><a href="docs/describing/../../flowstdlib/src/control/index/index.html">index</a></li>
<li><a href="docs/describing/../../flowstdlib/src/control/join/join.html">join</a></li>
<li><a href="docs/describing/../../flowstdlib/src/control/route/route.html">route</a></li>
<li><a href="docs/describing/../../flowstdlib/src/control/select/select.html">select</a></li>
<li><a href="docs/describing/../../flowstdlib/src/control/tap/tap.html">tap</a></li>
</ul>
<h3 id="looping"><a class="header" href="#looping">Looping</a></h3>
<p>Looping is not a natural construct in <code>flow</code>. If we look at how we would translate some use of loops from a 
procedural language to flow it might illustrate things.</p>
<p>For example, to perform an action or calculation 'n' times, we might well generate a range of 'n' values, create a
process that does the desired action or calculation, and then combine the two with a 'data flow control' function
such as <code>join</code>. Thus, the action/calculation can only produce an output for use downstream 'n' times, triggered
(possibly all in parallel) by the 'n' values that &quot;gate&quot; it's output.</p>
<h3 id="accumulating"><a class="header" href="#accumulating">Accumulating</a></h3>
<p>In procedural programming a loop can be used to accumulate a value (such as the total of the values in an array).</p>
<p>In <code>flow</code> there i sno global state and no variables that are persistent for a function across multiple invocations 
of it.</p>
<p>The mechanism we use to do this in <code>flow</code> is to use the <code>add</code> function, initializing one input <code>Once</code> with zero, 
sending values to the other input, looping back the output (the partial sum) to the first input, so that the sum 
(initialized to zero) is accumulated as values flow through it.</p>
<p>The same technique can be used to gather values into &quot;chunks&quot; of a determined size. One input of <code>accumulate</code> is 
initialized with an empty array (<code>[]</code>), the other input receives the elements to gather, and we feed back the 
array of elements gathered so far, and so on until the desired size of chunk is accumulated. </p>
<h3 id="nested-loops"><a class="header" href="#nested-loops">Nested Loops</a></h3>
<p>What would be a nested for loop in a procedural program can be implemented by putting two flows in series, with
one feeding the other. </p>
<p>For example in the <a href="docs/describing/../../flowsamples/sequence-of-sequences/root.toml">sequence-of-sequences</a> 
example a first instance of a <code>sequence</code> flow generates a series of &quot;limits&quot; for sequence of sequences to count up to.</p>
<p>A value for the start of each sequence, and the series of sequence limits is fed into another instance of the 
<code>sequence</code> function. This second flow generates a sequence each time it receives a set of inputs specifying the start
and end of the sequence.</p>
<ul>
<li>a first sequence is defined with start=1, end=10, step = 1 and hence generates: 1..10</li>
<li>a second sequence is defined
<ul>
<li>the start input is initialized always to 0</li>
<li>the step input is initialized always to 1 </li>
</ul>
</li>
<li>a connection is defined from the output of the first sequence to the <code>end</code> input of the second sequence
<ul>
<li>thus it generates 0,1,0,1,2,0,1,2,3    ending    0,1,2,3,4,5,6,7,8,9,10</li>
</ul>
</li>
</ul>
<h3 id="wrapping-processes-for-convenience"><a class="header" href="#wrapping-processes-for-convenience">Wrapping processes for convenience</a></h3>
<p>Another mechanism used for convenience (it may abbreviate written flows) is to have a simple flow to wrap a function or
process for a common use case, maybe initializing an input with a pre-defined value or creating feedback loops around 
the process to create a specific behaviour.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="args-contextargs"><a class="header" href="#args-contextargs">Args (//context/args)</a></h2>
<p>Functions to handle run-time arguments, command line arguments from invocation, etc</p>
<ul>
<li><a href="flowr/src/cli/args/get.html">get</a> - get the arguments the flow was invoked with</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="args-contextargsget"><a class="header" href="#args-contextargsget">Args (//context/args/get)</a></h2>
<p>Get the arguments the flow was executed with</p>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<pre><code class="language-toml">function = &quot;get&quot;
source = &quot;get.rs&quot;
docs = &quot;get.md&quot;
impure = true

[[output]]
name = &quot;string&quot;
type = &quot;array/string&quot;

[[output]]
name = &quot;json&quot;
type = &quot;array/&quot;
</code></pre>
<h3 id="include-using"><a class="header" href="#include-using">Include using</a></h3>
<pre><code class="language-toml">[[process]]
alias = &quot;get&quot;
source = &quot;context://args/get&quot;
</code></pre>
<h3 id="inputs"><a class="header" href="#inputs">Inputs</a></h3>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<ul>
<li>string - Array of Strings of the command line arguments the flow was invoked with.</li>
<li>json - Array of Json parsed values of the command line arguments the flow was invoked with.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="file-contextfile"><a class="header" href="#file-contextfile">File (//context/file)</a></h2>
<p>Functions to interact with the Environment, related to file input and output.</p>
<ul>
<li><a href="flowr/src/cli/file/file_write.html">write</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="write-contextfilewrite"><a class="header" href="#write-contextfilewrite">Write (//context/file/write)</a></h2>
<p>Writes <code>bytes</code> of data supplied to the file named <code>filename</code>, creating it if necessary.</p>
<h3 id="definition-1"><a class="header" href="#definition-1">Definition</a></h3>
<pre><code class="language-toml"> function = &quot;file_write&quot;
source = &quot;file_write.rs&quot;
docs = &quot;file_write.md&quot;
impure = true

[[input]]
name = &quot;filename&quot;
type = &quot;string&quot;

[[input]]
name = &quot;bytes&quot;
type = &quot;array/number&quot;
</code></pre>
<h3 id="include-using-1"><a class="header" href="#include-using-1">Include using</a></h3>
<pre><code class="language-toml">[[process]]
alias = &quot;write&quot;
source = &quot;context://file/write&quot;
</code></pre>
<h3 id="inputs-1"><a class="header" href="#inputs-1">Inputs</a></h3>
<ul>
<li><code>bytes</code> - the data to be written to the file</li>
<li><code>filename</code> - String with the name of the file to be written, absolute or relative to the current working
directory of the process invoking the flow.</li>
</ul>
<h4 id="outputs"><a class="header" href="#outputs">Outputs</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h2 id="image--contextimage"><a class="header" href="#image--contextimage">Image  (//context/image)</a></h2>
<p>Functions to write to Images</p>
<ul>
<li><a href="flowr/src/cli/image/image_buffer.html">image_buffer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="imagebuffer-contextimageimage_buffer"><a class="header" href="#imagebuffer-contextimageimage_buffer">ImageBuffer (//context/image/image_buffer)</a></h2>
<p>Write <code>pixels</code> to an image buffer</p>
<h3 id="definition-2"><a class="header" href="#definition-2">Definition</a></h3>
<pre><code class="language-toml">function = &quot;image_buffer&quot;
source = &quot;image_buffer.rs&quot;
docs = &quot;image_buffer.md&quot;
impure = true

[[input]]
name = &quot;pixel&quot;
type = &quot;array/number&quot;

[[input]]
name = &quot;value&quot;
type = &quot;array/number&quot;

[[input]]
name = &quot;size&quot;
type = &quot;array/number&quot;

[[input]]
name = &quot;filename&quot;
type = &quot;string&quot;
</code></pre>
<h3 id="include-using-2"><a class="header" href="#include-using-2">Include using</a></h3>
<pre><code class="language-toml">[[process]]
alias = &quot;buffer&quot;
source = &quot;context://file/image_buffer&quot;
</code></pre>
<h3 id="inputs-2"><a class="header" href="#inputs-2">Inputs</a></h3>
<ul>
<li><code>pixel</code> - the (x, y) of the pixel</li>
<li><code>value</code> - the (r, g, b) triplet to write to the pixel</li>
<li><code>size</code>  - the (width, height) of the image buffer</li>
<li><code>filename</code> - the file name to persist the buffer to</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stdio-contextstdio"><a class="header" href="#stdio-contextstdio">Stdio (//context/stdio)</a></h2>
<p>Functions to interact with the Environment, related to standard input and output (and error).</p>
<p>The values sent to these functions are read from standard input of the process that launched the flow
causing the function to block until input (or EOF) is detected. Output is printed on the STDOUT/STDERR
of the process invoking the flow.</p>
<ul>
<li><a href="flowr/src/cli/stdio/readline.html">readline</a></li>
<li><a href="flowr/src/cli/stdio/stderr.html">stderr</a></li>
<li><a href="flowr/src/cli/stdio/stdin.html">stdin</a></li>
<li><a href="flowr/src/cli/stdio/stdout.html">stdout</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="readline-contextstdioreadline"><a class="header" href="#readline-contextstdioreadline">Readline (//context/stdio/readline)</a></h2>
<p>Read a line of text from the STDIN of the process invoking the flow. The line is terminated by EOL
but leading and trailing whitespace are trimmed before being output.</p>
<p>The function will be scheduled for running again, until EOF is detected, after which it will not run
again.</p>
<h3 id="definition-3"><a class="header" href="#definition-3">Definition</a></h3>
<pre><code class="language-toml">function = &quot;readline&quot;
source = &quot;readline.rs&quot;
docs = &quot;readline.md&quot;
impure = true

[[output]]
name = &quot;string&quot;
type = &quot;string&quot;

[[output]]
name = &quot;json&quot;
</code></pre>
<h3 id="include-using-3"><a class="header" href="#include-using-3">Include using</a></h3>
<pre><code class="language-toml">[[process]]
alias = &quot;readline&quot;
source = &quot;context://stdio/readline&quot;
</code></pre>
<h3 id="inputs-3"><a class="header" href="#inputs-3">Inputs</a></h3>
<h4 id="output-1"><a class="header" href="#output-1">Output</a></h4>
<ul>
<li>text - Line of text read from STDIN - with leading and trailing whitespace trimmed.</li>
<li>json - Json value parsed from from STDIN</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stdin-contextstdiostdin"><a class="header" href="#stdin-contextstdiostdin">Stdin (//context/stdio/stdin)</a></h2>
<p>Read text from the STDIN of the process invoking the flow until EOF is detected, after which it will not run
again. If you wish to get the value of a line (i.e. after ENTER is pressed, then use <a href="flowr/src/cli/stdio/readline.html">readline</a>)</p>
<h3 id="definition-4"><a class="header" href="#definition-4">Definition</a></h3>
<pre><code class="language-toml">function = &quot;stdin&quot;
source = &quot;stdin.rs&quot;
docs = &quot;stdin.md&quot;
impure = true

[[output]]
name = &quot;string&quot;
type = &quot;string&quot;

[[output]]
name = &quot;json&quot;
</code></pre>
<h3 id="include-using-4"><a class="header" href="#include-using-4">Include using</a></h3>
<pre><code class="language-toml">[[process]]
alias = &quot;stdin&quot;
source = &quot;context://stdio/stdin&quot;
</code></pre>
<h3 id="inputs-4"><a class="header" href="#inputs-4">Inputs</a></h3>
<h3 id="output-2"><a class="header" href="#output-2">Output</a></h3>
<ul>
<li>text - Text read from STDIN - with leading and trailing whitespace (including EOF) trimmed.</li>
<li>json - Json value parsed from from STDIN</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stdout-contextstdiostdout"><a class="header" href="#stdout-contextstdiostdout">Stdout (//context/stdio/stdout)</a></h2>
<p>Output text to the STDOUT of the process invoking the flow. If an array is passed then each element
is output on a separate line.</p>
<h3 id="definition-5"><a class="header" href="#definition-5">Definition</a></h3>
<pre><code class="language-toml">function = &quot;stdout&quot;
source = &quot;stdout.rs&quot;
docs = &quot;stdout.md&quot;
impure = true

[[input]]
</code></pre>
<h3 id="include-using-5"><a class="header" href="#include-using-5">Include using</a></h3>
<pre><code class="language-toml">[[process]]
alias = &quot;stdout&quot;
source = &quot;context://stdio/stdout&quot;
</code></pre>
<h3 id="input"><a class="header" href="#input">Input</a></h3>
<ul>
<li>(default) - the object to output a String representation of (String, boolean, Number, array)</li>
</ul>
<h3 id="output-3"><a class="header" href="#output-3">Output</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stderr-contextstdiostderr"><a class="header" href="#stderr-contextstdiostderr">Stderr (//context/stdio/stderr)</a></h2>
<p>Output text to the STDERR of the process invoking the flow. If an array is passed then each element
is output on a separate line.</p>
<h3 id="definition-6"><a class="header" href="#definition-6">Definition</a></h3>
<pre><code class="language-toml">function = &quot;stderr&quot;
source = &quot;stderr.rs&quot;
docs = &quot;stderr.md&quot;
impure = true

[[input]]
</code></pre>
<h3 id="include-using-6"><a class="header" href="#include-using-6">Include using</a></h3>
<pre><code class="language-toml">[[process]]
alias = &quot;stderr&quot;
source = &quot;context://stdio/stderr&quot;
</code></pre>
<h3 id="input-1"><a class="header" href="#input-1">Input</a></h3>
<ul>
<li>(default) - the object to output a String representation of (string, boolean, number, array)</li>
</ul>
<h4 id="output-4"><a class="header" href="#output-4">Output</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h2 id="running-flows"><a class="header" href="#running-flows">Running Flows</a></h2>
<p>In order to run a flow, it must first be compiled. Then a &quot;flow runner&quot; (such as <code>flowr</code>) can be used to run the
compiled flow manifest.</p>
<p>For convenience, <code>flowc</code>, the flow compiler, compiles the flow, then uses <code>flowr</code> to run it for you (unless you 
specify otherwise). So that is the easiest way to run a flow and is used below.</p>
<p>If you have run <code>make</code> or <code>make install_flow</code> then you will have <code>flowc</code> and <code>flowr</code> installed on your system.
Be sure they are in your $PATH so that can be invoked directly.</p>
<p>Then you can run flows easily using <code>flowc</code>. </p>
<p>If you do not wish to install <code>flowc</code> then you can run it using <code>cargo</code> from the root of the project directory by
substituting <code>cargo run -p flowc --</code> for <code>flowc</code>in the examples below.</p>
<p>User's terminal Current Working Directory should be the root directory of the <code>flow</code> project</p>
<h3 id="finding-libraries"><a class="header" href="#finding-libraries">Finding Libraries</a></h3>
<p>Environment variable <code>$FLOW_LIB_PATH</code> is set to the target directory where the <code>flowstdlib</code> is compiled by default 
<code>${flow_root_dir}/target</code>, in order for <code>flowc</code> and <code>flowr</code> to be able to find library functions used.</p>
<p>If this environment variable is not set then compiling will fail:</p>
<pre><code> unset FLOW_LIB_PATH
 flowc -C flowr/src/cli flowsamples/fibonacci
error: Could not resolve the url: 'lib://flowstdlib/math/add'
caused by: Could not resolve library Url 'lib://flowstdlib/math/add' using Search Path 'FLOW_LIB_PATH': Directories: {}, URLs: {}
</code></pre>
<p>Directories to add to the library search path to help find libraries used can be passed to <code>flowc</code> via one or more
instances of the <code>-L, --libdir &lt;LIB_DIR|BASE_URL&gt;</code> Option (see below for an example).</p>
<h3 id="full-list-of-flowc-options"><a class="header" href="#full-list-of-flowc-options">Full List of <code>flowc</code> Options</a></h3>
<p>See the next section <a href="docs/running/flowc.html">flowc</a> for a description of the command line arguments it accepts.</p>
<h3 id="example-invocations"><a class="header" href="#example-invocations">Example Invocations</a></h3>
<ul>
<li>
<p><code>flowc -C flowr/src/cli flowsamples/fibonacci</code></p>
<p>uses the <code>context_functions</code> provided by <code>flowr</code> and run the flow whose root flow is defined in <code>./flowsamples/fibonacci/root.toml</code>. 
Do not pass in any arguments to the flow. </p>
<ul>
<li>You should get a fibonacci series output to the terminal, </li>
</ul>
</li>
<li>
<p><code>echo &quot;Hello&quot; | flowc -C flowr/src/cli flowsamples/reverse-echo</code> - This samples reads from STDIN so we echo in 
some text.</p>
<ul>
<li>
<p>You may see some output like:</p>
<p><code>Testing /Users/andrew/workspace/flow/flowsamples/reverse-echo/reverse/Cargo.toml WASM Project Compiling /Users/andrew/workspace/flow/flowsamples/reverse-echo/reverse/Cargo.toml WASM project</code></p>
<p>the first time this sample is run as the <code>provided function</code> is tested and compiled to WASM, followed by</p>
<p><code>olleH</code></p>
<p>which is the input string &quot;Hello&quot; reversed.</p>
</li>
</ul>
</li>
<li>
<p><code>unset FLOW_LIB_PATH;flowc -C flowr/src/cli -L target flowsamples/fibonacci</code> - first ensures that the $FLOW_LIB_PATH
environment variable is not set and is not being used to locate libraries, and in order to help <code>flowc</code> and <code>flowr</code> 
find the <code>flowstdlib</code> library used by the sample (previously compiled into <code>target</code> directory) it specified that as a
directory for the library search path using the <code>-L, --libdir &lt;LIB_DIR|BASE_URL&gt;</code> Option</p>
<ul>
<li>You should get a fibonacci series output to the terminal, </li>
</ul>
</li>
<li>
<p><code>flowc -C flowr/src/cli flowsamples/sequence 10</code> - as previous examples except that after the <code>source_url</code> a 
<code>flow_argument</code> of &quot;10&quot; is passed in</p>
<ul>
<li>A short sequence of numbers (2, 5, 8) and a string will be printed. The &quot;10&quot; represents the maximum of the sequence.</li>
</ul>
</li>
</ul>
<h3 id="running-a-flow-from-the-web"><a class="header" href="#running-a-flow-from-the-web">Running a flow from the web</a></h3>
<p>As stated, the <code>source_url</code> can be a Url to a web resource, or a flow definition hosted on a web server.</p>
<h3 id="example-running-a-flow-from-the-web"><a class="header" href="#example-running-a-flow-from-the-web">Example running a flow from the web</a></h3>
<p>We can use a flow that is part of the <code>flow</code> project, where the flow definition is hosted on the web by GitHub:</p>
<p><code>flowc -C flowr/src/cli &quot;https://raw.githubusercontent.com/andrewdavidmackenzie/flow/master/flowcore/tests/test-flows/hello-world/root.toml&quot;</code></p>
<p>That will pull the flow definition content from the web, compile it and run it, producing the expected output:</p>
<p><code>Hello World!</code></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flowc-command-line-arguments"><a class="header" href="#flowc-command-line-arguments"><code>flowc</code> Command Line Arguments</a></h2>
<p><code>flowc</code> is the flow &quot;compiler&quot;, although compiling a flow is very different to a procedural language compile.</p>
<p>What it and other components do is described in more detail later in the <a href="docs/running/../internals/overview.html">Internals</a> section.</p>
<p>This section describes command line arguments that can be supplied to <code>flowc</code> and what they are useful for.</p>
<h3 id="getting-help"><a class="header" href="#getting-help">Getting help</a></h3>
<p>Use <code>-h, --help</code> (e.g. <code>flowc -h</code> or <code>cargo run -p flowc -- -h</code>) to print out help for the usage of <code>flowc</code>. </p>
<p>This will print something like this:</p>
<pre><code class="language-shell script">Usage: flowc [OPTIONS] [source_url] [flow_args]...

Arguments:
  [source_url]    path or url for the flow or library to compile
  [flow_args]...  List of arguments get passed to the flow when executed

Options:
  -d, --debug
          Generate symbols for debugging. If executing the flow, do so with the debugger
  -c, --compile
          Compile the flow and implementations, but do not execute
  -C, --context_root &lt;CONTEXT_DIRECTORY&gt;
          Set the directory to use as the root dir for context function definitions
  -l, --lib
          Compile a flow library
  -n, --native
          Compile only native (not wasm) implementations when compiling a library
  -L, --libdir &lt;LIB_DIR|BASE_URL&gt;
          Add a directory or base Url to the Library Search path
  -t, --tables
          Write flow and compiler tables to .dump and .dot files
  -g, --graphs
          Create .dot files for graphs then generate SVGs with 'dot' command (if available)
  -m, --metrics
          Show flow execution metrics when execution ends
  -w, --wasm
          Use wasm library implementations when executing flow
  -O, --optimize
          Optimize generated output (flows and wasm)
  -p, --provided
          Provided function implementations should NOT be compiled from source
  -o, --output &lt;OUTPUT_DIR&gt;
          Specify the output directory for generated manifest
  -v, --verbosity &lt;VERBOSITY_LEVEL&gt;
          Set verbosity level for output (trace, debug, info, warn, error (default))
  -i, --stdin &lt;STDIN_FILENAME&gt;
          Read STDIN from the named file
  -h, --help
          Print help information
  -V, --version
          Print version information
</code></pre>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<ul>
<li><code>-d, --debug</code> Generate symbols for debugging. If executing the flow, do so with the debugger</li>
<li><code>-c, --compile</code> Compile the flow and implementations, but do not execute</li>
<li><code>-C, --context_root &lt;CONTEXT_DIRECTORY&gt;</code> Set the directory to use as the root dir for context function definitions</li>
<li><code>-l, --lib</code> Compile a flow library. The <code>source_url</code> supplied should be the root of the library to compile.</li>
<li><code>-n, --native</code> Compile only native (not wasm) implementations when compiling a library</li>
<li><code>-L, --libdir &lt;LIB_DIR|BASE_URL&gt;</code> Add a directory or base Url to the Library Search path</li>
<li><code>-t, --tables</code> Write flow and compiler tables to .dump and .dot files</li>
<li><code>-g, --graphs</code> Create .dot files for graphs then generate SVGs with 'dot' command (if available)</li>
<li><code>-m, --metrics</code> Show flow execution metrics when execution ends</li>
<li><code>-w, --wasm</code> Use wasm library implementations (not any statically linked native implementations) when executing flow</li>
<li><code>-O, --optimize</code> Optimize generated output (flows and wasm)</li>
<li><code>-p, --provided</code> Provided function implementations should NOT be compiled</li>
<li><code>-o, --output &lt;OUTPUT_DIR&gt;</code> Specify the output directory for generated manifest</li>
<li><code>-v, --verbosity &lt;VERBOSITY_LEVEL&gt;</code> Set verbosity level for output (trace, debug, info, warn, error (default))</li>
<li><code>-i, --stdin &lt;STDIN_FILENAME&gt;</code> Read STDIN from the named file</li>
<li><code>-h, --help</code> Print help information</li>
<li><code>-V, --version</code> Print version information</li>
</ul>
<h3 id="source_url"><a class="header" href="#source_url"><code>source_url</code></a></h3>
<p>After the Options you can supply an optional field for where to load the root flow from. This can be a relative or 
absolute path when no Url scheme is used, an absolute path if the <code>file://</code> scheme is used or a web resources if
either the <code>http</code> or <code>https</code> scheme is used.</p>
<ul>
<li>If no argument is supplied, it assumes the current directory as the argument, and continues as below</li>
<li>If it's a directory then it attempts to load &quot;root.toml&quot; from within the directory</li>
<li>If it's a file then it attempts to load the root flow from that file</li>
</ul>
<h3 id="flow_args"><a class="header" href="#flow_args"><code>flow_args</code></a></h3>
<p>If a flow directory or filename is supplied for <code>source_url</code>, then any arguments after that are assumed to be arguments 
for the flow itself. When it starts executing it can retrieve the value of these parameters using <code>context functions</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="passing-command-line-arguments"><a class="header" href="#passing-command-line-arguments">Passing Command Line Arguments</a></h3>
<p>Arguments are passed to the flow being executed by <code>flowc</code> by placing them after the flow name in 
the execution string (either using <code>cargo run -p flowc</code> or <code>flowc</code> directly). 
e.g. <code>cargo run -p flowc -- samples/mandlebrot mandel.png 4000x3000 -1.20,0.35 -1,0.20</code></p>
<p>The <code>context</code> functions include a function called <code>args/get</code> that can be used to read the arguments, 
allowing them to then be processed in the flow like any other inputs.</p>
<p>Include the <code>args/get</code> function in your flow:</p>
<pre><code class="language-toml">[[process]]
alias = &quot;args&quot;
source = &quot;lib://flkowr/args/get&quot;
</code></pre>
<p>Then create a connection from the desired output (second arg in this example) of <code>args/get</code> to another function:</p>
<pre><code class="language-toml">[[connection]]
from = &quot;function/args/2&quot;
to = &quot;function/parse_bounds/input&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="specifying-the-flows-root-file-to-load"><a class="header" href="#specifying-the-flows-root-file-to-load">Specifying the flow's root file to load</a></h3>
<h4 id="supported-file-extensions-and-formats"><a class="header" href="#supported-file-extensions-and-formats">Supported File Extensions and Formats</a></h4>
<p><code>flowc</code> supports TOML, JSON and YAML file formats. It assumes these file extensions: &quot;.toml&quot;, &quot;yaml&quot;|&quot;yml&quot; or &quot;json&quot;.</p>
<h4 id="flow-root-file-argument"><a class="header" href="#flow-root-file-argument">Flow root file argument</a></h4>
<p>The flow &quot;path&quot; argument (if present) can be a local (relative or absolute) file name, a &quot;file:///&quot; Url or an
&quot;http://&quot; or &quot;https://&quot; Url.</p>
<p>When the argument is not present it assumes a local file is being loaded, from the Current Working Directory,
using the Local File algorithm described below.</p>
<p>When the &quot;file:///&quot; Url scheme is used it assumes a local file as described below.</p>
<p>When &quot;http://&quot; or &quot;https://&quot; schemes are used, it will use the Url loading algorithm described below.</p>
<h4 id="local-file"><a class="header" href="#local-file">Local File</a></h4>
<p><code>flowc</code> tries to load a flow from it's root file using one of these three methods:</p>
<ul>
<li>If an existing directory path is specified, it looks for the default root flow file name (&quot;root.{}&quot;) in that 
directory, for each of the supported extensions. The first matching filename.extension is loaded.
<ul>
<li>E.g. <code>flowc</code> will load <code>./root.toml</code> if it exists</li>
<li>E.g. <code>flowc dirname</code> will load <code>./dirname/root.toml</code> if the file exists</li>
<li>E.g. <code>flowc /dirname</code> will load <code>/dirname/root.toml</code> if the file exists</li>
</ul>
</li>
<li>If a path to an existing file is passed, it uses that as the filename of the flow root file.
<ul>
<li>E.g. <code>flowc path/to/root.toml</code> will load <code>root.toml</code> from the <code>./path/to/</code> directory</li>
<li>E.g. <code>flowc path/to/root.yaml</code> will load <code>root.yaml</code> from the <code>./path/to/</code> directory, even if <code>root.json</code> 
and <code>root.toml</code> also exist </li>
</ul>
</li>
<li>If a path to an non-existent file or directory is passed, it will look for matching files with supported extensions
<ul>
<li>E.g. <code>flowc root</code> will load <code>./root.toml</code> if it exists in the Current Working Directory</li>
<li>E.g. <code>flowc root</code> will load <code>./root.json</code> if <code>root.toml</code> doesn't exist but <code>root.json</code> does</li>
<li>E.g. <code>flowc path/to/root</code> will load <code>path/to/root.toml</code> if it exists</li>
<li>E.g. <code>flowc path/to/root</code> will load <code>root.yaml</code> from the <code>./path/to/</code> directory, if it exists and <code>root.toml</code>
does not</li>
</ul>
</li>
<li>If a path to an existing directory is specified, it looks for a file named (&quot;dirname.{}&quot;) in that
directory (where dirname is the name of the directory), for each of the supported extensions.</li>
</ul>
<h4 id="urls-and-loading-from-the-web"><a class="header" href="#urls-and-loading-from-the-web">Urls and loading from the web</a></h4>
<p>The flow root file (http resource) will attempt to be loaded from the Url thus:</p>
<ul>
<li>The Url supplied, as-is</li>
<li>The Url supplied, appending each of the supported extensions (see above)</li>
<li>The Url supplied, appending &quot;/root.{extension}&quot; for each of the supported extensions</li>
<li>The Url supplied, appending &quot;/&quot; and the last path segment, for each of the supported extensions</li>
</ul>
<h4 id="why-the-dirname-option"><a class="header" href="#why-the-dirname-option">Why the dirname option?</a></h4>
<p>The dirname option above in the file and url algorithms is used to be able to name a flow (or library or other
file) after the directory it is in, and have it found specifying a shorter filename or url. Thus <code>path/dirname</code>
will find a file called <code>path/dirname/dirname.toml</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="standard-input"><a class="header" href="#standard-input">Standard Input</a></h3>
<p><code>context</code> provides functions to read from STDIN. You can pipe input to the flow by piping
it to the <code>cargo run -p flowc</code> or <code>flowc</code> command line used to execute the flow.</p>
<p>If not piped in, then the <code>stdin</code> function will attempt to read STDIN, blocking that function until input 
(or EOF) is provided. If input is read then it will be passed on by that function at its output.
The function will indicate to the run-time that it should be run again (to read more lines of STDIN)
and it will be re-added to the ready list and executed again later.</p>
<p>When EOF is detected, that function will indicate to the run-time that it does not want to be run again
and will not be added back to the ready list for re-execution.</p>
<h3 id="standard-output--standard-error"><a class="header" href="#standard-output--standard-error">Standard Output &amp; Standard Error</a></h3>
<p><code>context</code> provides functions to send output to STDOUT/STDERR. This output is printed on 
stdout or stderr of the process that executed the <code>cargo run -p flowc</code> or <code>flowc</code> command to execute the flow.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="exceptions-and-panics"><a class="header" href="#exceptions-and-panics">Exceptions and Panics</a></h3>
<p>Currently, there are no special provisions for handling or recovering from run-time exceptions.
The functions are implemented in rust and when they fail they will panic as usual in rust. 
The panic will be caught by the runtime and a crash avoided, and an error logged, but nothing else is done.</p>
<p>This may cause the result of the flow to not be what is expected, or to terminate early due to lack of jobs
to execute.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="running-flows-with-flowr"><a class="header" href="#running-flows-with-flowr">Running flows with <code>flowr</code></a></h2>
<p>In order to run a flow, it must first be compiled. Then a &quot;flow runner&quot; such as <code>flowr</code>can be used to run the compiled
flow manifest).</p>
<p>Flow runners in general and <code>flowr</code> run the compiled flow manifest (by default named <code>manifest.json</code>).</p>
<p>In order to compile a flow definition down to a flow manifest that can be run, you use <code>flowc</code> as usual, with the
addition of the <code>-c, --compile</code> option. This compiles the flow but does not invoke <code>flowr</code> to run it.</p>
<p>Then <code>flowr</code> as described below can be used to run the compiled flow.</p>
<p>This section describes command line arguments that can be supplied to <code>flowr</code> and what they are useful for.</p>
<h3 id="getting-help-1"><a class="header" href="#getting-help-1">Getting help</a></h3>
<p>Use <code>-h, --help</code> (e.g. <code>flowc -h</code> or <code>cargo run -p flowc -- -h</code>) to print out help for the usage of <code>flowc</code>. </p>
<p>This will print something like this:</p>
<pre><code class="language-shell script">Usage: flowr [OPTIONS] [flow-manifest] [flow_args]...

Arguments:
  [flow-manifest]  the file path of the 'flow' manifest file
  [flow_args]...   A list of arguments to pass to the flow.

Options:
  -d, --debugger                     Enable the debugger when running a flow
  -m, --metrics                      Calculate metrics during flow execution and print them out when done
  -n, --native                       Link with native (not WASM) version of flowstdlib
  -s, --server                       Launch as flowr server (only, no client)
  -c, --client                       Start flowr as a client (only, no server) to connect to a flowr server
  -C, --context                      Only execute 'context' jobs in the server
  -j, --jobs &lt;MAX_JOBS&gt;              Set maximum number of jobs that can be running in parallel)
  -L, --libdir &lt;LIB_DIR|BASE_URL&gt;    Add a directory or base Url to the Library Search path
  -t, --threads &lt;THREADS&gt;            Set number of threads to use to execute jobs (min: 1, default: cores available)
  -v, --verbosity &lt;VERBOSITY_LEVEL&gt;  Set verbosity level for output (trace, debug, info, warn, default: error)
  -h, --help                         Print help information
  -V, --version                      Print version information
</code></pre>
<h3 id="options-1"><a class="header" href="#options-1">Options</a></h3>
<p>-d, --debugger                     Enable the debugger when running a flow
-m, --metrics                      Calculate metrics during flow execution and print them out when done
-n, --native                       Link with native (not WASM) version of flowstdlib
-s, --server                       Launch as flowr server (only, no client)
-c, --client                       Start flowr as a client (only, no server) to connect to a flowr server
-C, --context                      Only execute 'context' jobs in the server
-j, --jobs &lt;MAX_JOBS&gt;              Set maximum number of jobs that can be running in parallel)
-L, --libdir &lt;LIB_DIR|BASE_URL&gt;    Add a directory or base Url to the Library Search path
-t, --threads <THREADS>            Set number of threads to use to execute jobs (min: 1, default: cores available)
-v, --verbosity &lt;VERBOSITY_LEVEL&gt;  Set verbosity level for output (trace, debug, info, warn, default: error)
-h, --help                         Print help information
-V, --version                      Print version information</p>
<p>Similarly to <a href="docs/running/flowc.html">flowc</a>, in order to locate libraries used in flow execution, <code>flowr</code> needs to know where to 
locate them. As for flowc, this can be done using the <code>$FLOW_LIB_PATH</code> environment variable, or one or more instance
of the <code>-L, --libdir &lt;LIB_DIR|BASE_URL&gt;</code> option.</p>
<h3 id="flow-manifest"><a class="header" href="#flow-manifest"><code>flow-manifest</code></a></h3>
<p>After the Options you can supply an optional field for where to load the root flow from. This can be a relative or 
absolute path when no Url scheme is used, an absolute path if the <code>file://</code> scheme is used or a web resources if
either the <code>http</code> or <code>https</code> scheme is used.</p>
<ul>
<li>If no argument is supplied, it assumes the current directory as the argument, and continues as below</li>
<li>If it's a directory then it attempts to load &quot;root.toml&quot; from within the directory</li>
<li>If it's a file then it attempts to load the root flow from that file</li>
</ul>
<h3 id="flow_args-1"><a class="header" href="#flow_args-1"><code>flow_args</code></a></h3>
<p>Any arguments after <code>flow-manifest</code> are assumed to be arguments for the flow itself. When it starts executing it can
retrieve the value of these parameters using <code>context functions</code>.</p>
<h3 id="example-invocations-1"><a class="header" href="#example-invocations-1">Example Invocations</a></h3>
<p>For each of these examples, there is first a <code>flowc</code> line showing how the flow can be compiled. This will leave
a compiled <code>manifest.json</code> flow manifest alongside the flow's root definition file. That manifest is then run using
<code>flowr</code></p>
<ul>
<li><code>flowc -C flowr/src/cli -c flowsamples/fibonacci</code> - compile the fibonacci sample</li>
<li><code>flowr flowsamples/fibonacci</code> - run the pre-compiled fibonacci sample flow manifest
<ul>
<li>You should get a fibonacci series output to the terminal,</li>
</ul>
</li>
<li><code>unset FLOW_LIB_PATH;flowc -C flowr/src/cli -c -L target flowsamples/fibonacci</code> - compile the flow</li>
<li><code>unset FLOW_LIB_PATH;flowr -L target flowsamples/fibonacci</code> - 
<ul>
<li>You should get a fibonacci series output to the terminal,</li>
</ul>
</li>
<li><code>flowc -C flowr/src/cli -c flowsamples/sequence</code> - compile the flow</li>
<li><code>flowr flowsamples/sequence 10</code> - compile the flow
<ul>
<li>A short sequence of numbers (2, 5, 8) and a string will be printed. The &quot;10&quot; represents the maximum of the sequence.</li>
</ul>
</li>
<li><code>flowr flowsamples/sequence/manifest.json 10</code> - compile the flow, specifying the full path to the manifest.json file</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="running-a-flow-in-clientserver-mode-of-flowr"><a class="header" href="#running-a-flow-in-clientserver-mode-of-flowr">Running a flow in client/server mode of <code>flowr</code></a></h2>
<h3 id="flowrlib-architecture"><a class="header" href="#flowrlib-architecture"><code>flowrlib</code> architecture</a></h3>
<p>The <code>flowrlib</code> library is designed to be used, not just in <code>flowr</code> CLI-style flow runners, but in other incarnations
such as a GUI application, or web application, etc.</p>
<p>In order to have <code>flowrlib</code> work well in such applications, it avoids running any <code>context function</code> function that
interacts with the environment (Read/Write to a FIle, Read/Write to STDIO, etc) and that may block, on the main
thread running the &quot;coordinator&quot; that managers flow execution.</p>
<p>Different applications, like a GUI App, may need to provide totally different implementations for some of 
those functions, provided by the application and not the library.</p>
<p>For this reason, it implements a &quot;client/server&quot; architecture, where a &quot;server&quot; thread runs the coordinator
and sends and receives messages to a client thread (in the flow runner app) that runs the <code>context functions</code> whose 
implementations are provided by the flow runner application that links the <code>flowrlib</code> library.</p>
<h3 id="flowr---an-example-of-a-flow-runner-app"><a class="header" href="#flowr---an-example-of-a-flow-runner-app"><code>flowr</code> - an example of a flow runner app</a></h3>
<p><code>flowr</code> is one example of a flow runner app that uses <code>flowrlib</code> to build an application to run flows.</p>
<p>It implements a set of <code>client function</code>, that interact with STDIO etc, on a client thread.</p>
<p>The <code>flowr</code> process running that client thread must be able to interact with STDIO.</p>
<p>In normal use, <code>flowr</code> runs the client and server threads in the same process and the user is unaware of this
separation.</p>
<h3 id="separating-the-client-from-the-server"><a class="header" href="#separating-the-client-from-the-server">Separating the client from the server</a></h3>
<p>However, <code>flowr</code> can be run as two separate processes, one &quot;client&quot; process that executes the <code>context functions</code>
and interacts with STDIO, and another &quot;server&quot; process with a thread that that runs the coordinator plus a number 
of threads running executors for job execution.</p>
<p>These two &quot;client&quot; and &quot;server&quot; processes exchange messages over the network.
The two processes can be on the same node/machine or on separate machines. The one running the &quot;client&quot;
should be able to interact with the FileSystem and STDIO and interact with the user. The &quot;server&quot; does not run
any such function and does not need to interact with the user.</p>
<p>They use mDNS and service discovery to discover the network address and port of the other process, running within
the same network.</p>
<h3 id="example-of-running-a-flow-with-client-separate-from-server"><a class="header" href="#example-of-running-a-flow-with-client-separate-from-server">Example of running a flow with &quot;client&quot; separate from &quot;server&quot;</a></h3>
<p>First let's compile the fibonacci sample (but not run it) by using <code>flowc</code> with the <code>-c, --compile</code> option:</p>
<p><code>&gt;  flowc -c -C flowr/src/cli flowsamples/fibonacci</code></p>
<p>Let's check that worked:</p>
<pre><code>&gt; ls flowsamples/fibonacci/manifest.json
flowsamples/fibonacci/manifest.json
</code></pre>
<p>In Terminal 1, lets start the server that will wait for a flow to be submitted for execution,
using <code>flowr</code> with debug logging verbosity level to be able to see what it's doing.</p>
<p><code>&gt; flowr -n -s -v debug</code></p>
<p>which will log some lines, ending with:</p>
<p><code>INFO    - Server is waiting to receive a 'Submission'</code></p>
<p>In Terminal 2, let's start a client using <code>flowr</code> with the <code>-c, --client</code> option. 
This will submit the flow to the server for execution over the network, reading the flow manifest from the File
System. It will then execute the <code>client functions</code>, in response to messages from the server, providing STDIO (just 
standard out in this example)</p>
<p><code>&gt; flowr -c flowsamples/fibonacci</code></p>
<p>That will produce the usual fibonacci series on the STDOUT of Terminal 2.</p>
<p>Logs of what is happening in order to execute the flow will be produced by the server in Terminal 1, ending with </p>
<p><code>INFO    - Server is waiting to receive a 'Submission'</code></p>
<p>which indicates the server has returned to the initial state, ready to receive another flow for execution.</p>
<p>You can execute the flow again by repeating the same command in Terminal 2.</p>
<p>In order to exit the server, in Terminal 1 just hit Control-C.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="distributed-execution-of-jobs-with-flowr-and-flowrex"><a class="header" href="#distributed-execution-of-jobs-with-flowr-and-flowrex">Distributed execution of jobs with <code>flowr</code> and <code>flowrex</code></a></h2>
<h3 id="job-dispatch-and-job-execution"><a class="header" href="#job-dispatch-and-job-execution">Job Dispatch and Job Execution</a></h3>
<p>The <code>flowrlib</code> that is used by flow runner applications to execute a flow has two important functions:</p>
<ul>
<li>job dispatch - that managers the state of the flow, the dispatch of jobs for execution, and distribution
of results received back, passing those results onto other functions in the flow etc.</li>
<li>job execution - this is the execution of &quot;pure&quot; functions, receiving a set of input data, a reference
to the function's implementation. It executes it with the provided input, and returns the job including
the results.</li>
</ul>
<p>Job dispatch is done by the server thread running the coordinator, responsible for maintaining a consistent 
state for the flow and it's functions and coordinating the distribution of results and enabling of
new functions to be run.</p>
<p>Additional threads are started for job execution, allowing many jobs to be executed concurrently, and
in parallel on a multi-core machine. Job execution on &quot;pure&quot; functions can run in isolation, just needing
the input data and the function implementation.</p>
<h3 id="normal-execution"><a class="header" href="#normal-execution">Normal Execution</a></h3>
<p>Normally, the <code>flowr</code> process runs the coordinator in one thread and a number of executors in additional
threads.</p>
<p>However, due to the &quot;pure&quot; nature of the job execution, it can be done anywhere, including in additional 
processes, or on processes in additional machines.</p>
<h3 id="flowrex-executor-binary"><a class="header" href="#flowrex-executor-binary"><code>flowrex</code> executor binary</a></h3>
<p><code>florex</code> is an additional small binary that is built. 
It cannot coordinate the execution of a flow but it can execute (just library for now) jobs.</p>
<p>Additional instances of <code>flowrex</code> can be started in other processes on the same machine and have it 
execute some of the jobs, increasing compute resources and concurrency/parallelism of flow execution.</p>
<p>It is possible to start <code>flowr</code> with 0 executor threads and force <code>flowrex</code> to execute all the 
(library) jobs.</p>
<p>It can also be ran on another node, even one with a different architecture such as ARM, on the network and have job 
execution done entirely by it or shared with flowr.</p>
<p>How many jobs are done in one process/machine or another depends on the number of executors and network and cpu speed.</p>
<p>The <code>flowr</code> flow runner and the <code>flowrex</code> job executor discover each other using mDNS
and then jobs are distributed out over the network and results are sent back
to the coordinator running in <code>flowr</code> also over the network.</p>
<h3 id="todo"><a class="header" href="#todo">TODO</a></h3>
<p>It is pending to allow <code>flowrec</code> to also execute provided functions, by distributing the architecture-neutral WASM 
function implementations to other nodes and hence allow them to load and run those functions also.</p>
<h3 id="example-of-distributed-execution"><a class="header" href="#example-of-distributed-execution">Example of distributed execution</a></h3>
<p>This can be done in two terminals on the same machine, or across two machines of the same or different CPU architecture.</p>
<p>Terminal 1</p>
<p>Start an instance of <code>flowrex</code> that will wait for jobs to execute.
(we start with debug logging level to see what's happening)</p>
<p><code>&gt; flowrex -v debug</code></p>
<p>The log output should end with</p>
<p><code>INFO    - Waiting for beacon matching 'jobs._flowr._tcp.local'</code></p>
<p>indicating that it is waiting to discover the <code>flowr</code> process on the network.</p>
<p>Terminal 2</p>
<p>First let's compile the fibonacci sample (but not run it) by using <code>flowc</code> with the <code>-c, --compile</code> option:</p>
<p><code>&gt;  flowc -c -C flowr/src/cli flowsamples/fibonacci</code></p>
<p>Let's check that worked:</p>
<pre><code>&gt; ls flowsamples/fibonacci/manifest.json
flowsamples/fibonacci/manifest.json
</code></pre>
<p>Then let's run the sample fibonacci flow, forcing zero executors threads so that we 
see <code>flowrex</code> executing all (non context) jobs</p>
<p><code>&gt; flowr -t 0 flowsamples/fibonacci</code></p>
<p>That will produce the usual fibonacci series on the STDOUT of Terminal 2, then <code>flowr</code> exiting</p>
<p>Logs of what is happening in order to execute the flow jobs will be produced in Terminal 1, ending with the same line
as before:</p>
<p><code>INFO    - Waiting for beacon matching 'jobs._flowr._tcp.local'</code></p>
<p>Indicating that it has returned to the initial state and is ready to discover a new flowr dispatcher of jobs to it.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="the-flow-debugger"><a class="header" href="#the-flow-debugger">The Flow Debugger</a></h3>
<p>NOTE: To be able to use the flow debugger that is part of <code>flowr</code>, <code>flowr</code> must be compiled with
the <code>&quot;debugger&quot;</code> feature enabled. If not, the debugger code is not included in <code>flowr</code>.</p>
<h4 id="compiling-with-debug-symbols"><a class="header" href="#compiling-with-debug-symbols">Compiling with Debug Symbols</a></h4>
<p>The debugger can be used to debug any flow, but flows compiled by <code>flowc</code> using the <code>-g</code> or <code>--symbols</code>
option will have extra human readable content included in the compiled manifest (names of processes
etc) and be more convenient to debug.</p>
<h4 id="running-the-flow-with-the-debugger"><a class="header" href="#running-the-flow-with-the-debugger">Running the flow with the debugger</a></h4>
<p>To start debugging a flow, run it using <code>flowr</code> as normal, but using the <code>-d</code> or <code>--debugger</code>
options.</p>
<p>The compiled flow manifest will be loaded by <code>flowr</code> as usual, functions initialized and a command prompt
for the debugger will be shown.</p>
<p>You can use the <code>'h'</code> or <code>'help'</code> command at the prompt to to get help on debugger commands.</p>
<p>If you want to inspect the state of the flow at a particular point to debug a problem or understand 
its execution then you will probably want to either set some breakpoints initially before running the 
flow, or to step through the flow's execution one function invocation at a time.</p>
<p>Those can be done using the <code>Break</code> command to set breakpoints, the <code>List</code> command to list breakpoints set,
the <code>Run</code> command to start flow execution, the <code>Continue</code> command to continue execution after a breakpoint triggers,
and the <code>Step</code> command to step forward one function invocation.</p>
<h4 id="debugger-commands"><a class="header" href="#debugger-commands">Debugger Commands</a></h4>
<ul>
<li>
<p>Break: Set a breakpoint on a function (by id), an output or an input using spec:
** function_id
** source_id/output_route ('source_id/' for default output route)
** destination_id:input_number
** blocked_process_id-&gt;blocking_process_id</p>
</li>
<li>
<p>Continue: Continue execution until next breakpoint or end of execution</p>
</li>
<li>
<p>Delete a breakpoint: Delete the breakpoint matching {spec} or all breakpoints with '*'</p>
</li>
<li>
<p>Exit: Stop flow execution and exit debugger</p>
</li>
<li>
<p>Help: Display this help message</p>
</li>
<li>
<p>List breakpoints: List all breakpoints</p>
</li>
<li>
<p>Print: Print the overall state, or state of process number 'n'</p>
</li>
<li>
<p>Quit: Stop flow execution and exit debugger (same as Exit)</p>
</li>
<li>
<p>Run: Run the flow or if running already then reset the state to initial state</p>
</li>
<li>
<p>Step: Step over the next 'n' jobs (default = 1) then break</p>
</li>
<li>
<p>Validate: Run a series of defined checks to validate the status of flow</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flowstdlib-overview"><a class="header" href="#flowstdlib-overview"><code>flowstdlib</code> Overview</a></h1>
<p>See also: <a href="http://andrewdavidmackenzie.github.io/flow/code/doc/flowstdlib/index.html">Code docs</a></p>
<p><code>flowstdlib</code> is a standard library of functions and flows for <code>flow</code> programs to use.</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p><code>flowstdlib</code> contains the following modules:</p>
<ul>
<li><a href="docs/developing/../../flowstdlib/src/control/control.html"><code>control</code></a></li>
<li><a href="docs/developing/../../flowstdlib/src/data/data.html"><code>data</code></a></li>
<li><a href="docs/developing/../../flowstdlib/src/fmt/fmt.html"><code>fmt</code></a></li>
<li><a href="docs/developing/../../flowstdlib/src/math/math.html"><code>math</code></a></li>
</ul>
<h2 id="use-by-the-compiler"><a class="header" href="#use-by-the-compiler">Use by the Compiler</a></h2>
<p>In order for the compiler to be able to find the library's <code>flow</code> and <code>function</code> definitions, the directory containing
this library must be part of <code>FLOW_LIB_PATH</code> or specified using an instance of the <code>-L</code> command line option to <code>flowc</code>, </p>
<p>NOTE: That flows are compiled down to a graph of functions at compile time, and do not exist at runtime.</p>
<h2 id="building-this-library-from-source"><a class="header" href="#building-this-library-from-source">Building this library from Source</a></h2>
<p>Libraries like <code>flowstdlib</code> are built using <code>flowc</code> with the <code>-l</code> option. </p>
<p>This builds a directory tree (in <code>target/{lib_name}</code>) of all required files for a portable library, including:-</p>
<ul>
<li>documentation files (.md MarkDown files, .dot graphs of flows, graphs rendered as .dot.svg SVG files)</li>
<li>TOML definition files for flows and functions</li>
<li>Function implementations compiled to a .wasm WASM file</li>
<li>A <code>manifest.json</code> manifest of the libraries functions and where the implementations (.wasm files) can be found.
This is used by the Runtime to be able to load it.</li>
</ul>
<h2 id="dual-nature-of-flow-libraries"><a class="header" href="#dual-nature-of-flow-libraries">Dual nature of flow libraries</a></h2>
<p>Flow libraries such as <code>flowstdlib</code> have a dual nature. They can compiled and linked natively to a binary such
as <code>flowr</code>, or when compiled by <code>flowc</code> (using the <code>-l</code>) all the functions implementations are compiled to
<code>.wasm</code> WASM files.</p>
<h2 id="native-use-by-a-runtime"><a class="header" href="#native-use-by-a-runtime">Native use by a Runtime</a></h2>
<p><code>flowr</code> offers the <code>-n/--native</code> option for the <code>flowstdlib</code> to be used natively. When used, functions it
contains will be run natively (machine code), as opposed to WASM implementations of the functions.</p>
<h2 id="wasm-use-by-a-runtime"><a class="header" href="#wasm-use-by-a-runtime">WASM use by a Runtime</a></h2>
<p>If the <code>-n/--native</code> option is not used, and the library manifest (<code>manifest.json</code>) is found by the flow 
runner (e.g. <code>flowr</code>) at runtime (using<code>FLOW_LIB_PATH</code> or <code>-L</code>), then the manifest is read and the functions 
WASM implementations found and loaded.</p>
<p>When a job is executed that requires one of these library functions, the WASM implementation is run.</p>
<h2 id="configuring-flow_lib_path-during-development"><a class="header" href="#configuring-flow_lib_path-during-development">Configuring <code>FLOW_LIB_PATH</code> during development</a></h2>
<p>If you are using it as part of the larger <code>flow</code> workspace then you just need the <code>flow</code> project root directory
in your <code>FLOW_LIB_PATH</code> as described above (or added to the lib search part using the <code>-L &lt;dir&gt;</code> option).</p>
<h2 id="features"><a class="header" href="#features">features</a></h2>
<p>These are the conditionally compiled features of <code>flowstdlib</code>:</p>
<ul>
<li>default - No features are enabled by default</li>
<li>wasm - feature to enable compile of functions to WASM implementation. If not activated, the WASM implementations
will not be compiled and the library must be linked natively as described above.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="control-flowstdlibcontrol"><a class="header" href="#control-flowstdlibcontrol">Control (//flowstdlib/control)</a></h2>
<p>Functions and flows to control the flow of data in a flow based on control inputs.</p>
<h2 id="list-of-functions-and-flows"><a class="header" href="#list-of-functions-and-flows">List of Functions and Flows</a></h2>
<ul>
<li><a href="flowstdlib/src/control/compare_switch/compare_switch.html"><code>compare_switch</code></a></li>
<li><a href="flowstdlib/src/control/index/index.html"><code>index</code></a></li>
<li><a href="flowstdlib/src/control/index_f.html"><code>index_f</code></a></li>
<li><a href="flowstdlib/src/control/join/join.html"><code>join</code></a></li>
<li><a href="flowstdlib/src/control/route/route.html"><code>route</code></a></li>
<li><a href="flowstdlib/src/control/select/select.html"><code>select</code></a></li>
<li><a href="flowstdlib/src/control/tap/tap.html"><code>tap</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="compareswitch-flowstdlibcontrolcompare_switch"><a class="header" href="#compareswitch-flowstdlibcontrolcompare_switch">CompareSwitch (//flowstdlib/control/compare_switch)</a></h2>
<h3 id="description"><a class="header" href="#description">Description</a></h3>
<p>Compares two input values and outputs the right hand and left hand values on different outputs, 
depending on the comparison result:</p>
<h4 id="equal"><a class="header" href="#equal"><strong>equal</strong></a></h4>
<p>The left/right value is output on the &quot;equal&quot; output</p>
<h4 id="greater-than"><a class="header" href="#greater-than"><strong>greater than</strong></a></h4>
<p>The left value is output on the &quot;left-gt&quot;, right value on the &quot;right-gt&quot; output</p>
<h4 id="greater-than-or-equal"><a class="header" href="#greater-than-or-equal"><strong>greater than or equal</strong></a></h4>
<p>The left value is output on the &quot;left-gte&quot;, right value on the &quot;right-gte&quot; output</p>
<h4 id="less-than"><a class="header" href="#less-than"><strong>less than</strong></a></h4>
<p>The left value is output on the &quot;left-lt&quot; output, right value is output on the &quot;right-lt&quot; output
####<strong>less than or equal</strong>
The left value is output on the &quot;left-lte&quot; output, right value is output on the &quot;right-lte&quot; output</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/control/compare_switch&quot;
</code></pre>
<h3 id="definition-7"><a class="header" href="#definition-7">Definition</a></h3>
<pre><code class="language-toml">function = &quot;compare_switch&quot;
source = &quot;compare_switch.rs&quot;
docs = &quot;compare_switch.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;left&quot; # - left hand input
type = &quot;number&quot;

[[input]]
name = &quot;right&quot; # - right hand input
type = &quot;number&quot;

[[output]]
name = &quot;equal&quot; # - outputs right hand value if the two values are equal
type = &quot;number&quot;

[[output]]
name = &quot;right-lt&quot; # - outputs right hand value if the left hand value is less than the right hand value
type = &quot;number&quot;

[[output]]
name = &quot;right-lte&quot; # - outputs right hand value if the left hand value is less than or equal to the right hand value
type = &quot;number&quot;

[[output]]
name = &quot;right-gt&quot; # - outputs right hand value if the left hand value is greater than the right hand value
type = &quot;number&quot;

[[output]]
name = &quot;right-gte&quot; # - outputs right hand value if the left hand value is greater than or equal to the right hand value
type = &quot;number&quot;

[[output]]
name = &quot;left-lt&quot; # - outputs left hand value if the left hand value is less than the right hand value
type = &quot;number&quot;

[[output]]
name = &quot;left-lte&quot; # - outputs left hand value if the left hand value is less than or equal to the right hand value
type = &quot;number&quot;

[[output]]
name = &quot;left-gt&quot; # - outputs left hand value if the left hand value is greater than the right hand value
type = &quot;number&quot;

[[output]]
name = &quot;left-gte&quot; # - outputs left hand value if the left hand value is greater than or equal to the right hand value
type = &quot;number&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="index-flowstdlibcontrolindex"><a class="header" href="#index-flowstdlibcontrolindex">Index (//flowstdlib/control/index)</a></h2>
<p>Pass thru a value based on the index of an item in the stream of values</p>
<h3 id="definition-8"><a class="header" href="#definition-8">Definition</a></h3>
<pre><code class="language-toml">function = &quot;index&quot;
source = &quot;index.rs&quot;
docs = &quot;index.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;value&quot; # - the stream of input values to select from

[[input]]
name = &quot;previous_value&quot; # - the loop-backed previous value to enable selecting &quot;last&quot;

[[input]]
name = &quot;previous_index&quot; # - the loop-backed previous index to enable counting
type = &quot;number&quot;

[[input]]
name = &quot;select_index&quot; # th index to select from, where -1 = &quot;last&quot;
type = &quot;number&quot;

[[output]]
name = &quot;index&quot; # the index of the value just processed and output on &quot;value&quot;
type = &quot;number&quot;

[[output]]
name = &quot;value&quot; # the value just processed

[[output]]
name = &quot;selected_value&quot; # the value selected by index - only output when selected
</code></pre>
<h3 id="include-using-7"><a class="header" href="#include-using-7">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/control/index&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="index_f-flowstdlibcontrolindex_f"><a class="header" href="#index_f-flowstdlibcontrolindex_f">index_f (//flowstdlib/control/index_f)</a></h2>
<p>A flow wrapper for the <a href="flowstdlib/src/control/index/index.html">index</a> function to simplify its use by supplying most frequently
used initializers to some inputs. </p>
<h3 id="definition-9"><a class="header" href="#definition-9">Definition</a></h3>
<pre><code class="language-toml">flow = &quot;index_f&quot;
docs = &quot;index_f.md&quot;

[metadata]
description = &quot;A wrapper flow to simplify the use of the index function for standard use cases&quot;

[[input]]
name = &quot;value&quot;

[[input]]
name = &quot;select_index&quot;
type = &quot;number&quot;

[[output]]
name = &quot;selected_value&quot;

# the index function we wrap
[[process]]
source = &quot;lib://flowstdlib/control/index&quot;
input.previous_index = { once = -1 } # so first value through will get an index of 0
input.previous_value = { once = 42 } # fake

# connect up inputs
[[connection]]
from = &quot;input/value&quot;
to = &quot;index/value&quot;

[[connection]]
from = &quot;input/select_index&quot;
to = &quot;index/select_index&quot;

# loopback connections
[[connection]]
from = &quot;index/value&quot;
to = &quot;index/previous_value&quot;

[[connection]]
from = &quot;index/index&quot;
to = &quot;index/previous_index&quot;

# connect up output
[[connection]]
from = &quot;index/selected_value&quot;
to = &quot;output/selected_value&quot;
</code></pre>
<h3 id="include-using-8"><a class="header" href="#include-using-8">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/control/index_f&quot;
</code></pre>
<h3 id="flow-graoh"><a class="header" href="#flow-graoh">Flow Graoh</a></h3>
<p><a href="flowstdlib/src/control/index_f.dot.svg" target="_blank"><img src="flowstdlib/src/control/index_f.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="join-flowstdlibcontroljoin"><a class="header" href="#join-flowstdlibcontroljoin">Join (//flowstdlib/control/join)</a></h2>
<p>Control the flow of a piece of data by waiting for a second value to be available</p>
<h3 id="definition-10"><a class="header" href="#definition-10">Definition</a></h3>
<pre><code class="language-toml">function = &quot;join&quot;
source = &quot;join.rs&quot;
docs = &quot;join.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;data&quot; # - the data we wish to control the flow of

[[input]]
name = &quot;control&quot; # - a second value we wait on

[[output]]
</code></pre>
<h3 id="include-using-9"><a class="header" href="#include-using-9">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/control/join&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="route-flowstdlibcontrolroute"><a class="header" href="#route-flowstdlibcontrolroute">Route (//flowstdlib/control/route)</a></h2>
<p>Route data to one or another based on a boolean control value.</p>
<h3 id="definition-11"><a class="header" href="#definition-11">Definition</a></h3>
<pre><code class="language-toml">function = &quot;route&quot;
source = &quot;route.rs&quot;
docs = &quot;route.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;data&quot; # - the data flow we wish to control the flow if

[[input]]
name = &quot;control&quot; # - a boolean value to determine which output roue `data` is passed to
type = &quot;boolean&quot;

[[output]]
name = &quot;true&quot; # `if `control` is true `data` is routed here

[[output]]
name = &quot;false&quot; # if `control` is false `data` is routed here
</code></pre>
<h3 id="include-using-10"><a class="header" href="#include-using-10">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/control/route&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="select-flowstdlibcontrolselect"><a class="header" href="#select-flowstdlibcontrolselect">Select (//flowstdlib/control/select)</a></h2>
<p>Select which data to output, based on a boolean control value.</p>
<h3 id="definition-12"><a class="header" href="#definition-12">Definition</a></h3>
<pre><code class="language-toml">function = &quot;select&quot;
source = &quot;select.rs&quot;
docs = &quot;select.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;i1&quot;

[[input]]
name = &quot;i2&quot;

[[input]]
name = &quot;control&quot; # - a boolean value to selection of inputs passed to outputs
type = &quot;boolean&quot;

[[output]]
name = &quot;select_i1&quot; # if `control` is true `i1` is selected for this output else `i2` is selected

[[output]]
name = &quot;select_i2&quot; # if `control` is true `i2` is selected for this output else `i1` is selected
</code></pre>
<h3 id="include-using-11"><a class="header" href="#include-using-11">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/control/select&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tap-flowstdlibcontroltap"><a class="header" href="#tap-flowstdlibcontroltap">Tap (//flowstdlib/control/tap)</a></h2>
<p>Control the flow of data (flow it through this function, or have it disappear) based on a boolean control value.</p>
<h3 id="definition-13"><a class="header" href="#definition-13">Definition</a></h3>
<pre><code class="language-toml">function = &quot;tap&quot;
source = &quot;tap.rs&quot;
docs = &quot;tap.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;data&quot; # - the data flow we wish to control the flow if

[[input]]
name = &quot;control&quot; # - a boolean value to determine in `data` is passed on or not
type = &quot;boolean&quot;

[[output]] # `data` is output if `control` is true, nothing if `control` is false
</code></pre>
<h3 id="include-using-12"><a class="header" href="#include-using-12">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/control/tap&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="control-flowstdlibcontrol-1"><a class="header" href="#control-flowstdlibcontrol-1">Control (//flowstdlib/control)</a></h2>
<p>Some generic processes that act on data.</p>
<h2 id="list-of-functions-and-flows-1"><a class="header" href="#list-of-functions-and-flows-1">List of Functions and Flows</a></h2>
<ul>
<li><a href="flowstdlib/src/data/accumulate/accumulate.html"><code>accumulate</code></a></li>
<li><a href="flowstdlib/src/data/append/append.html"><code>append</code></a></li>
<li><a href="flowstdlib/src/data/count/count.html"><code>count</code></a></li>
<li><a href="flowstdlib/src/data/duplicate/duplicate.html"><code>duplicate</code></a></li>
<li><a href="flowstdlib/src/data/duplicate_rows/duplicate_rows.html"><code>duplicate_rows</code></a></li>
<li><a href="flowstdlib/src/data/enumerate/enumerate.html"><code>enumerate</code></a></li>
<li><a href="flowstdlib/src/data/info/info.html"><code>info</code></a></li>
<li><a href="flowstdlib/src/data/multiply_row/multiply_row.html"><code>multiply_row</code></a></li>
<li><a href="flowstdlib/src/data/ordered_split/ordered_split.html"><code>ordered_split</code></a></li>
<li><a href="flowstdlib/src/data/remove/remove.html"><code>remove</code></a></li>
<li><a href="flowstdlib/src/data/sort/sort.html"><code>sort</code></a></li>
<li><a href="flowstdlib/src/data/split/split.html"><code>split</code></a></li>
<li><a href="flowstdlib/src/data/transpose/transpose.html"><code>transpose</code></a></li>
<li><a href="flowstdlib/src/data/zip/zip.html"><code>zip</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="accumulate-flowstdlibdataaccumulate"><a class="header" href="#accumulate-flowstdlibdataaccumulate">Accumulate (//flowstdlib/data/accumulate)</a></h2>
<p>Accumulate input values into an array upto the limit specified</p>
<h3 id="definition-14"><a class="header" href="#definition-14">Definition</a></h3>
<pre><code class="language-toml">function = &quot;accumulate&quot;
source = &quot;accumulate.rs&quot;
docs = &quot;accumulate.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;values&quot; # - The stream of input values to accumulate into an array

[[input]]
name = &quot;partial&quot; # - A partial array, to use in the accumulation, adding next input `value` to it

[[input]]
name = &quot;chunk_size&quot; # - The size of the array we want to create
type = &quot;number&quot;

[[output]]
name = &quot;chunk&quot; # - The accumulated array of inputs of size `limit` or more
type = &quot;array/&quot;

[[output]]
name = &quot;partial&quot; # - The partially accumulated array, of size smaller than `chunk_size`

[[output]]
name = &quot;chunk_size&quot; # - The chunk-size, output for use downstream or in loop-back
type = &quot;number&quot;
</code></pre>
<h3 id="include-using-13"><a class="header" href="#include-using-13">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/accumulate&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="accumulate-flowstdlibdataappend"><a class="header" href="#accumulate-flowstdlibdataappend">Accumulate (//flowstdlib/data/append)</a></h2>
<p>Append two strings</p>
<h3 id="definition-15"><a class="header" href="#definition-15">Definition</a></h3>
<pre><code class="language-toml">function = &quot;append&quot;
source = &quot;append.rs&quot;
docs = &quot;append.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;s1&quot;
type = &quot;string&quot;

[[input]]
name = &quot;s2&quot;
type = &quot;string&quot;

[[output]]
type = &quot;string&quot; # - The Concatenated string
</code></pre>
<h3 id="include-using-14"><a class="header" href="#include-using-14">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/append&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="count-flowstdlibdatacount"><a class="header" href="#count-flowstdlibdatacount">Count (//flowstdlib/data/count)</a></h2>
<p>Takes a value on it's input and sends the same value on it's output and adds one to the count
received on 'count' input and outputs new count on 'count' output</p>
<h3 id="definition-16"><a class="header" href="#definition-16">Definition</a></h3>
<pre><code class="language-toml">function = &quot;count&quot;
source = &quot;count.rs&quot;
docs = &quot;count.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;data&quot; # the value to count and pass on

[[input]]
name = &quot;count&quot; # - the count before this data item

[[output]]
name = &quot;data&quot; # - the value passed on

[[output]]
name = &quot;count&quot; # - the incremented count of values passed thru
</code></pre>
<h3 id="include-using-15"><a class="header" href="#include-using-15">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/count&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="duplicate-flowstdlibdataduplicate"><a class="header" href="#duplicate-flowstdlibdataduplicate">Duplicate (//flowstdlib/data/duplicate)</a></h2>
<p>Takes a value on it's input and sends the same value <code>factor</code> times in an array output</p>
<h3 id="definition-17"><a class="header" href="#definition-17">Definition</a></h3>
<pre><code class="language-toml">function = &quot;duplicate&quot;
source = &quot;duplicate.rs&quot;
docs = &quot;duplicate.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;value&quot; # - the value to duplicate, generic type (i.e. all types accepted)

[[input]]
name = &quot;factor&quot; # - how many times to duplicate the value in the output
type = &quot;number&quot;

[[output]]
type = &quot;array/&quot; # - the array of duplicate values, of generic type (i.e. the same type as input)
</code></pre>
<h3 id="include-using-16"><a class="header" href="#include-using-16">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/duplicate&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="duplicaterows-flowstdlibdataduplicate_rows"><a class="header" href="#duplicaterows-flowstdlibdataduplicate_rows">DuplicateRows (//flowstdlib/data/duplicate_rows)</a></h2>
<p>Duplicate the rows of a matrix</p>
<h3 id="definition-18"><a class="header" href="#definition-18">Definition</a></h3>
<pre><code class="language-toml">function = &quot;duplicate_rows&quot;
source = &quot;duplicate_rows.rs&quot;
docs = &quot;duplicate_rows.md&quot;
type = &quot;rust&quot;

[[input]]
type = &quot;array/array/number&quot; # Input matrix

[[input]]
name = &quot;factor&quot; # - duplication factor
type = &quot;number&quot;

[[output]]
type = &quot;array/array/number&quot; # - matrix with duplicated rows
</code></pre>
<h3 id="include-using-17"><a class="header" href="#include-using-17">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/duplicate_rows&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="enumerate-flowstdlibdataenumerate"><a class="header" href="#enumerate-flowstdlibdataenumerate">Enumerate (//flowstdlib/data/enumerate)</a></h2>
<p>Enumerate the elements of an array</p>
<p>With an input array such as <code>[&quot;a&quot;, &quot;b&quot;]</code> it will assign an index to each element
and produce an output array of tuples (array of two elements) such as <code>[[0, &quot;a&quot;], [1, &quot;b&quot;]]</code></p>
<h3 id="definition-19"><a class="header" href="#definition-19">Definition</a></h3>
<pre><code class="language-toml">function = &quot;enumerate&quot;
source = &quot;enumerate.rs&quot;
docs = &quot;enumerate.md&quot;
type = &quot;rust&quot;

[[input]]
type = &quot;array/&quot;          # e.g. [&quot;a&quot;, &quot;b&quot;]

[[output]]
type = &quot;array/array/&quot;  # e.g. [[0, &quot;a&quot;], [1, &quot;b&quot;]]
</code></pre>
<h3 id="include-using-18"><a class="header" href="#include-using-18">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/enumerate&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="info-flowstdlibdatainfo"><a class="header" href="#info-flowstdlibdatainfo">Info (//flowstdlib/data/info)</a></h2>
<p>Output info about the input value</p>
<h3 id="definition-20"><a class="header" href="#definition-20">Definition</a></h3>
<pre><code class="language-toml">function = &quot;info&quot;
source = &quot;info.rs&quot;
docs = &quot;info.md&quot;
type = &quot;rust&quot;

[[input]] # - Input value

[[output]]
name = &quot;type&quot; # - String identifying the type of the input value
type = &quot;string&quot;

[[output]]
name = &quot;rows&quot; # - Number of rows in the input value
type = &quot;number&quot;

[[output]]
name = &quot;columns&quot; # - Number of columns in the input value
type = &quot;number&quot;
</code></pre>
<h3 id="include-using-19"><a class="header" href="#include-using-19">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/info&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="multiplyrow-flowstdlibdatamultiply_row"><a class="header" href="#multiplyrow-flowstdlibdatamultiply_row">MultiplyRow (//flowstdlib/data/multiply_row)</a></h2>
<p>Multiply two matrix rows to a product</p>
<h3 id="definition-21"><a class="header" href="#definition-21">Definition</a></h3>
<pre><code class="language-toml">function = &quot;multiply_row&quot;
source = &quot;multiply_row.rs&quot;
docs = &quot;multiply_row.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;a&quot;
type = &quot;array/number&quot;

[[input]]
name = &quot;b&quot;
type = &quot;array/number&quot;

[[output]]
type = &quot;number&quot;
</code></pre>
<h3 id="include-using-20"><a class="header" href="#include-using-20">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/multiply_row&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="orderedsplit-flowstdlibdataordered_split"><a class="header" href="#orderedsplit-flowstdlibdataordered_split">OrderedSplit (//flowstdlib/data/ordered_split)</a></h2>
<p>Split a string into (possibly) its constituent parts based on a separator.</p>
<p>It guarantees to produce an array of strings, ordered the same as the input string.</p>
<h3 id="definition-22"><a class="header" href="#definition-22">Definition</a></h3>
<pre><code class="language-toml">function = &quot;ordered_split&quot;
source = &quot;ordered_split.rs&quot;
docs = &quot;ordered_split.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;string&quot; # - the String to split
type = &quot;string&quot;

[[input]]
name = &quot;separator&quot; # - the String to use as a separator
type = &quot;string&quot;

[[output]]
type = &quot;array/string&quot;
</code></pre>
<h3 id="include-using-21"><a class="header" href="#include-using-21">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/ordered_split&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="remove-flowstdlibdataremove"><a class="header" href="#remove-flowstdlibdataremove">Remove (//flowstdlib/data/remove)</a></h2>
<p>Remove a value from a vector of values</p>
<h3 id="definition-23"><a class="header" href="#definition-23">Definition</a></h3>
<pre><code class="language-toml">function = &quot;remove&quot;
source = &quot;remove.rs&quot;
docs = &quot;remove.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;value&quot; # - The value to remove from the array

[[input]]
name = &quot;array&quot; # - An array, to remove `value` from
type = &quot;array/&quot;

[[output]]
type = &quot;array/&quot; # - The resulting array
</code></pre>
<h3 id="include-using-22"><a class="header" href="#include-using-22">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/remove&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sort-flowstdlibdatasort"><a class="header" href="#sort-flowstdlibdatasort">Sort (//flowstdlib/data/sort)</a></h2>
<p>Sort an array of numbers</p>
<h3 id="definition-24"><a class="header" href="#definition-24">Definition</a></h3>
<pre><code class="language-toml">function = &quot;sort&quot;
source = &quot;sort.rs&quot;
docs = &quot;sort.md&quot;
type = &quot;rust&quot;

[[input]]
type = &quot;array/number&quot;

[[output]]
type = &quot;array/number&quot;
</code></pre>
<h3 id="include-using-23"><a class="header" href="#include-using-23">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/sort&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="split-flowstdlibdatasplit"><a class="header" href="#split-flowstdlibdatasplit">Split (//flowstdlib/data/split)</a></h2>
<p>Split a string into (possibly) two parts and a possible token, based on a separator.</p>
<p>This function is implemented in a deliberate way to be able to showcase parallelization.</p>
<p>Instead of going through the string in order looking for the separator and gathering an array
of sections it takes an alternative approach.</p>
<p>It starts in the middle of the string looking for a separator character from there towards the
end. If it finds one then the string is split in two and those two sub-strings are output as
an array of strings on the <code>partial</code> output. NOTE that either or both of these two sub-strings
may have separators within them, and hence need further subdivision.</p>
<p>For that reason, the <code>partial</code> output is feedback to the <code>string</code> input, and the runtime will
serialize the array of strings to the input as separate strings.</p>
<p>If from the middle to the end no separator is found, then it tries from the middle backwards
towards the beginning. If a separator is found, the two sub-strings are output on <code>partial</code>
output as before.</p>
<p>If no separator is found in either of those cases, then the string doesn't have any and is
output on the <code>token</code> output.</p>
<p>Thus, strings with separators are subdivided until strings without separators are found, and
each of those is output as a token.</p>
<p>Due to the splitting and recursion approach, the order of the output tokens is not the order
they appear in the string.</p>
<h3 id="definition-25"><a class="header" href="#definition-25">Definition</a></h3>
<pre><code class="language-toml">function = &quot;split&quot;
source = &quot;split.rs&quot;
docs = &quot;split.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;string&quot; # - the String to split
type = &quot;string&quot;

[[input]]
name = &quot;separator&quot; # - the String to use as a separator
type = &quot;string&quot;

[[output]]
name = &quot;partial&quot; # - an array of Strings that each may or may not have `separator` strings inside
# them. This should be feed-back to the input (will be serialized into Strings by the
# runtime) for further subdivision until each one cannot be split further - in which case
# it will be output as `token`
type = &quot;array/string&quot;

[[output]]
name = &quot;token-count&quot; # - the number of tokens emitted, can be used to count tokens generated
type = &quot;number&quot;

[[output]]
name = &quot;token&quot; # - a String that cannot be sub-divided further.
type = &quot;string&quot;

[[output]]
name = &quot;delta&quot; # - this is a Number that indicates if this job reduced (-1) or increased (+1) the number
# of pending jobs to complete the split task. e.g. it consumes the input string, ot there is one
# less to process. If it outputs a token then the delta to pending work is -1 (-1 input consumed
# -0 partials for further splitting). If the input string
# is split into two partial strings that are output for further splitting, then the delta to
# pending work is +1 (+2 partials -1 input)
type = &quot;number&quot;
</code></pre>
<h3 id="include-using-24"><a class="header" href="#include-using-24">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/split&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="transpose-flowstdlibdatatranspose"><a class="header" href="#transpose-flowstdlibdatatranspose">Transpose (//flowstdlib/data/transpose)</a></h2>
<p>Transpose a matricies rows and columns</p>
<h3 id="definition-26"><a class="header" href="#definition-26">Definition</a></h3>
<pre><code class="language-toml">function = &quot;transpose&quot;
source = &quot;transpose.rs&quot;
docs = &quot;transpose.md&quot;
type = &quot;rust&quot;

[[input]]
type = &quot;array/array/number&quot;

[[output]]
type = &quot;array/array/number&quot;
</code></pre>
<h3 id="include-using-25"><a class="header" href="#include-using-25">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/transpose&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="zip-flowstdlibdatazip"><a class="header" href="#zip-flowstdlibdatazip">Zip (//flowstdlib/data/zip)</a></h2>
<p>Takes two arrays of values and produce an array of tuples of pairs of values from each input array.</p>
<h3 id="definition-27"><a class="header" href="#definition-27">Definition</a></h3>
<pre><code class="language-toml">function = &quot;zip&quot;
source = &quot;zip.rs&quot;
docs = &quot;zip.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;left&quot; # - the 'left' array
type = &quot;array/&quot;

[[input]]
name = &quot;right&quot; # - the 'right' array
type = &quot;array/&quot;

[[output]]
name = &quot;tuples&quot; # - tuples - the array of tuples of (left, right)
type = &quot;array/&quot;
</code></pre>
<h3 id="include-using-26"><a class="header" href="#include-using-26">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/data/zip&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fmt-flowstdlibfmt"><a class="header" href="#fmt-flowstdlibfmt">Fmt (//flowstdlib/fmt)</a></h2>
<p>Functions for the formatting of values and conversion from one type to another.</p>
<h2 id="list-of-functions-and-flows-2"><a class="header" href="#list-of-functions-and-flows-2">List of Functions and Flows</a></h2>
<ul>
<li><a href="flowstdlib/src/fmt/reverse/reverse.html"><code>reverse</code></a></li>
<li><a href="flowstdlib/src/fmt/to_json/to_json.html"><code>to_json</code></a></li>
<li><a href="flowstdlib/src/fmt/to_string/to_string.html"><code>to_string</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reverse-flowstdlibfmtreverse"><a class="header" href="#reverse-flowstdlibfmtreverse">Reverse (//flowstdlib/fmt/reverse)</a></h2>
<p>Reverse a String</p>
<h3 id="definition-28"><a class="header" href="#definition-28">Definition</a></h3>
<pre><code class="language-toml">function = &quot;reverse&quot;
source = &quot;reverse.rs&quot;
docs = &quot;reverse.md&quot;
type = &quot;rust&quot;

[[input]]
type = &quot;string&quot; # The String to reverse

[[output]]
name = &quot;reversed&quot; # - The input string reversed
type = &quot;string&quot;

[[output]]
name = &quot;original&quot; # - The original input string
type = &quot;string&quot;
</code></pre>
<h3 id="include-using-27"><a class="header" href="#include-using-27">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/fmt/reverse&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tojson-flowstdlibfmtto_json"><a class="header" href="#tojson-flowstdlibfmtto_json">ToJson (//flowstdlib/fmt/to_json)</a></h2>
<p>Convert a String to Json</p>
<h3 id="definition-29"><a class="header" href="#definition-29">Definition</a></h3>
<pre><code class="language-toml">function = &quot;to_json&quot;
source = &quot;to_json.rs&quot;
docs = &quot;to_json.md&quot;
type = &quot;rust&quot;

[[input]]
type = &quot;string&quot; # The String to convert

[[output]]
</code></pre>
<h3 id="include-using-28"><a class="header" href="#include-using-28">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/fmt/to_json&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tostring-flowstdlibfmtto_string"><a class="header" href="#tostring-flowstdlibfmtto_string">ToString (//flowstdlib/fmt/to_string)</a></h2>
<p>Convert an input type to a String</p>
<p>Current types supported are:</p>
<ul>
<li>null - A null will be printed as &quot;null&quot;</li>
<li>boolean - boolean JSON value</li>
<li>number - A JSON Number</li>
<li>string - a bit redundant, but it works</li>
<li>array - An JSON array of values that can be converted, they are converted one by one</li>
<li>object - a Map of names/objects that will also be printed out</li>
</ul>
<h3 id="definition-30"><a class="header" href="#definition-30">Definition</a></h3>
<pre><code class="language-toml">function = &quot;to_string&quot;
source = &quot;to_string.rs&quot;
docs = &quot;to_string.md&quot;
type = &quot;rust&quot;

[[input]]

[[output]]
type = &quot;string&quot; # The String equivalent of the input value
</code></pre>
<h3 id="include-using-29"><a class="header" href="#include-using-29">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/fmt/to_string&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="math-flowstdlibmath"><a class="header" href="#math-flowstdlibmath">Math (//flowstdlib/math)</a></h2>
<p>Math Functions and flows</p>
<h2 id="list-of-functions-and-flows-3"><a class="header" href="#list-of-functions-and-flows-3">List of Functions and Flows</a></h2>
<ul>
<li><a href="flowstdlib/src/math/add/add.html"><code>add</code></a></li>
<li><a href="flowstdlib/src/math/compare/compare.html"><code>compare</code></a></li>
<li><a href="flowstdlib/src/math/divide/divide.html"><code>divide</code></a></li>
<li><a href="flowstdlib/src/math/multiply/multiply.html"><code>multiply</code></a></li>
<li><a href="flowstdlib/src/math/range.html"><code>range</code></a></li>
<li><a href="flowstdlib/src/math/range_split/range_split.html"><code>range_split</code></a></li>
<li><a href="flowstdlib/src/math/sequence.html"><code>sequence</code></a></li>
<li><a href="flowstdlib/src/math/sqrt/sqrt.html"><code>sqrt</code></a></li>
<li><a href="flowstdlib/src/math/subtract/subtract.html"><code>subtract</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="add-flowstdlibmathadd"><a class="header" href="#add-flowstdlibmathadd">Add (//flowstdlib/math/add)</a></h2>
<p>Add two inputs to produce a new output</p>
<h3 id="definition-31"><a class="header" href="#definition-31">Definition</a></h3>
<pre><code class="language-toml">function = &quot;add&quot;
source = &quot;add.rs&quot;
docs = &quot;add.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;i1&quot; # - first input of type `Number`
type = &quot;number&quot;

[[input]]
name = &quot;i2&quot; # - second input of type `Number`
type = &quot;number&quot;

[[output]]
type = &quot;number&quot;
</code></pre>
<h3 id="include-using-30"><a class="header" href="#include-using-30">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/math/add&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="compare-flowstdlibmathcompare"><a class="header" href="#compare-flowstdlibmathcompare">Compare (//flowstdlib/math/compare)</a></h2>
<p>Compare two input values and output different boolean values depending on if the comparison
is equal, greater than, greater than or equal, less than or less than or equal.</p>
<h3 id="definition-32"><a class="header" href="#definition-32">Definition</a></h3>
<pre><code class="language-toml">function = &quot;compare&quot;
source = &quot;compare.rs&quot;
docs = &quot;compare.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;left&quot; # - left hand input
type = &quot;number&quot;

[[input]]
name = &quot;right&quot; # - right hand input
type = &quot;number&quot;

[[output]]
name = &quot;equal&quot; # - `equal` - outputs true if the two values are equal
type = &quot;boolean&quot;

[[output]]
name = &quot;ne&quot; # - `ne` - outputs true if the two values are not equal
type = &quot;boolean&quot;

[[output]]
name = &quot;lt&quot; # - `lt` - outputs true if the left hand value is less than the right hand value
type = &quot;boolean&quot;

[[output]]
name = &quot;lte&quot; # - `lte` - outputs true if the left hand value is less than or equal to the right hand value
type = &quot;boolean&quot;

[[output]]
name = &quot;gt&quot; # - `gt` - outputs true if the left hand value is greater than the right hand value
type = &quot;boolean&quot;

[[output]]
name = &quot;gte&quot; # - `gte` - outputs true if the left hand value is greater than or equal to the right hand value
type = &quot;boolean&quot;
</code></pre>
<h3 id="include-using-31"><a class="header" href="#include-using-31">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/math/compare&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="divide-flowstdlibmathdivide"><a class="header" href="#divide-flowstdlibmathdivide">Divide (//flowstdlib/math/divide)</a></h2>
<p>Divide one input by another, producing outputs for the dividend, divisor, result and the remainder </p>
<h3 id="definition-33"><a class="header" href="#definition-33">Definition</a></h3>
<pre><code class="language-toml">function = &quot;divide&quot;
source = &quot;divide.rs&quot;
docs = &quot;divide.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;dividend&quot; # - the number to be divided, of type `Number`
type = &quot;number&quot;

[[input]]
name = &quot;divisor&quot; # - the number to divide by, of type `Number`
type = &quot;number&quot;

[[output]]
name = &quot;dividend&quot; # - re output the `dividend` input, of type `Number`
type = &quot;number&quot;

[[output]]
name = &quot;divisor&quot; # - re output the `divisor` input, of type `Number`
type = &quot;number&quot;

[[output]]
name = &quot;result&quot; # - the result of the division, of type `Number`
type = &quot;number&quot;

[[output]]
name = &quot;remainder&quot; # - the remainder of the division, of type `Number`
type = &quot;number&quot;
</code></pre>
<h3 id="include-using-32"><a class="header" href="#include-using-32">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/math/divide&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="multiply-flowstdlibmathmultiply"><a class="header" href="#multiply-flowstdlibmathmultiply">Multiply (//flowstdlib/math/multiply)</a></h2>
<p>Multiply one input by another</p>
<h3 id="definition-34"><a class="header" href="#definition-34">Definition</a></h3>
<pre><code class="language-toml">function = &quot;multiply&quot;
source = &quot;multiply.rs&quot;
docs = &quot;multiply.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;i1&quot; # - one number, of type `Number`
type = &quot;number&quot;

[[input]]
name = &quot;i2&quot; # - the other number, of type `Number`
type = &quot;number&quot;

[[output]]
type = &quot;number&quot; # - the multiplication of i1 and i2, of type `Number`
</code></pre>
<h3 id="include-using-33"><a class="header" href="#include-using-33">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/math/multiply&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="range-flowstdlibmathrange"><a class="header" href="#range-flowstdlibmathrange">Range (//flowstdlib/math/range)</a></h2>
<p>Generate numbers within a rnage</p>
<h3 id="definition-35"><a class="header" href="#definition-35">Definition</a></h3>
<pre><code class="language-toml">flow = &quot;range&quot;
docs = &quot;range.md&quot;

# The range to generate: [min, max] both are inclusive
[[input]]
name = &quot;range&quot;
type = &quot;array/number&quot;

# The series of numbers in the range generated
[[output]]
name = &quot;number&quot;
type = &quot;number&quot;

[[process]]
alias = &quot;range_split&quot;
source = &quot;lib://flowstdlib/math/range_split&quot;

[[connection]]
from = &quot;input/range&quot;
to = &quot;range_split/range&quot;

# Send the numbers (ranges that cannot be split further) to the output
[[connection]]
from = &quot;range_split/same&quot;
to = &quot;output/number&quot;

# Feedback the two sub-ranges for further splitting
[[connection]]
from = &quot;range_split/bottom&quot;
to = &quot;range_split/range&quot;

[[connection]]
from = &quot;range_split/top&quot;
to = &quot;range_split/range&quot;
</code></pre>
<h3 id="include-using-34"><a class="header" href="#include-using-34">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/math/range&quot;
</code></pre>
<h3 id="flow-graoh-1"><a class="header" href="#flow-graoh-1">Flow Graoh</a></h3>
<p><a href="flowstdlib/src/math/range.dot.svg" target="_blank"><img src="flowstdlib/src/math/range.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="range-flowstdlibmathrange_split"><a class="header" href="#range-flowstdlibmathrange_split">Range (//flowstdlib/math/range_split)</a></h2>
<p>Split a range of numbers into two sub-ranges, or output the number if they are the same</p>
<h3 id="definition-36"><a class="header" href="#definition-36">Definition</a></h3>
<pre><code class="language-toml">function = &quot;range_split&quot;
source = &quot;range_split.rs&quot;
docs = &quot;range_split.md&quot;
type = &quot;rust&quot;

# The range_split definition: an array of [smallest number in the range_split, The largest number in the range_split]
[[input]]
name = &quot;range&quot;
type = &quot;array/number&quot;

# This will be a new range (array of two numbers) in the bottom half of the input range_split
[[output]]
name = &quot;bottom&quot;
type = &quot;array/number&quot;

# This will be a new range (array of two numbers) in the top half of the input range_split
[[output]]
name = &quot;top&quot;
type = &quot;array/number&quot;

# Numbers in the range will be output here
[[output]]
name = &quot;same&quot;
type = &quot;number&quot;
</code></pre>
<h3 id="include-using-35"><a class="header" href="#include-using-35">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/math/range&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sequence-flowstdlibmathsequence"><a class="header" href="#sequence-flowstdlibmathsequence">Sequence (//flowstdlib/math/sequence)</a></h2>
<p>Generate a sequence of numbers</p>
<h3 id="definition-37"><a class="header" href="#definition-37">Definition</a></h3>
<pre><code class="language-toml">flow = &quot;sequence&quot;
docs = &quot;sequence.md&quot;

# The number the sequence should start at
[[input]]
name = &quot;start&quot;
type = &quot;number&quot;

# limit of the sequence
[[input]]
name = &quot;limit&quot;
type = &quot;number&quot;

# 'step' is the amount to add each time
[[input]]
name = &quot;step&quot;
type = &quot;number&quot;

# The sequence of numbers we will generate
[[output]]
name = &quot;sequence&quot;
type = &quot;number&quot;

# the last value is output when the sequence ends (may not be == limit if step is not 1)
[[output]]
name = &quot;last&quot;
type = &quot;number&quot;

# compare_switch will pass all numbers that are less than the limit on the &quot;right-lte&quot; output
[[process]]
source = &quot;lib://flowstdlib/control/compare_switch&quot;

# For the first time around, pass the start number of the sequence into &quot;compare_switch&quot;
[[connection]]
from = &quot;input/start&quot;
to = &quot;compare_switch/right&quot;
name = &quot;first&quot;

[[connection]]
from = &quot;input/limit&quot;
to = &quot;compare_switch/left&quot;
name = &quot;limit&quot;

# connect the /right-lte output of compare_switch to the output of this process - the sequence of numbers being generated
[[connection]]
from = &quot;compare_switch/right-lte&quot;
to = &quot;output/sequence&quot;
name = &quot;sequence&quot;

# while the sequence is running - loopback the left value (limit) to compare against next time
[[connection]]
from = &quot;compare_switch/left-gt&quot;
to = &quot;compare_switch/left&quot;
name = &quot;feedback-limit&quot;

# An add process to add one to the last output of the sequence each time, up to the penultimate one
[[process]]
source = &quot;lib://flowstdlib/math/add&quot;

[[connection]]
from = &quot;input/step&quot;
to = &quot;add/i2&quot;
name = &quot;step&quot;

# Take generated number of the sequence and pass it to 'add' to add one to it for the next number in the sequence
[[connection]]
from = &quot;compare_switch/right&quot;
to = &quot;add/i1&quot;
name = &quot;previous&quot;

# a tap process that controls the flow of the 'next' value from 'add' to 'compare_switch' at the end of sequence
[[process]]
alias = &quot;next-tap&quot;
source = &quot;lib://flowstdlib/control/tap&quot;

# After the first iteration, each time take the sum from the adder (i.e. possibly the next number in the sequence)
# and pass it into the compare_switch function to pass it through) if it's less than the limit
[[connection]]
from = &quot;add&quot;
to = &quot;next-tap/data&quot;

[[connection]]
from = &quot;not-last/lt&quot;
to = &quot;next-tap/control&quot;

[[connection]]
from = &quot;next-tap&quot;
to = &quot;compare_switch/right&quot;
name = &quot;next&quot;

# a tap process that controls the feedback of the 'step' value to 'add'
[[process]]
alias = &quot;step-tap&quot;
source = &quot;lib://flowstdlib/control/tap&quot;

# pass the 'step' value to the tap for the loopback
[[connection]]
from = &quot;add/i2&quot;
to = &quot;step-tap/data&quot;
name = &quot;step&quot;

# feedback the step, if it's not the last iteration
[[connection]]
from = &quot;step-tap&quot;
to = &quot;add/i2&quot;
name = &quot;feedback-step&quot;

# a comparer to see if this is the last iteration
[[process]]
alias = &quot;not-last&quot;
source = &quot;lib://flowstdlib/math/compare&quot;

# pass the limit to the comparer each time
[[connection]]
from = &quot;compare_switch/left&quot;
to = &quot;not-last/right&quot;
name = &quot;limit&quot;

# pass the previous value generated to the comparer each time
[[connection]]
from = &quot;compare_switch/right&quot;
to = &quot;not-last/left&quot;
name = &quot;previous&quot;

# pass the result of the comparison to the tap that allows the value to pass or disapear on the last iteration
[[connection]]
from = &quot;not-last/lt&quot;
to = &quot;step-tap/control&quot;
name = &quot;not-last&quot;

# When compare_switch determines the next value is too large (greater-than-or-equal to the limit) then
# the flow will end, output that value - whose presence indicates it's the end of the sequence
[[connection]]
from = &quot;compare_switch/right-gte&quot;
to = &quot;output/last&quot;
</code></pre>
<h3 id="include-using-36"><a class="header" href="#include-using-36">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/math/sequence&quot;
</code></pre>
<h3 id="flow-graoh-2"><a class="header" href="#flow-graoh-2">Flow Graoh</a></h3>
<p><a href="flowstdlib/src/math/sequence.dot.svg" target="_blank"><img src="flowstdlib/src/math/sequence.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sqrt-flowstdlibmathsqrt"><a class="header" href="#sqrt-flowstdlibmathsqrt">Sqrt (//flowstdlib/math/sqrt)</a></h2>
<p>Calculate the square root of a number</p>
<h3 id="definition-38"><a class="header" href="#definition-38">Definition</a></h3>
<pre><code class="language-toml">function = &quot;sqrt&quot;
source = &quot;sqrt.rs&quot;
docs = &quot;sqrt.md&quot;
type = &quot;rust&quot;

[[input]]
type = &quot;number&quot;

[[output]]
type = &quot;number&quot; # Square Root of type `Number`
</code></pre>
<h3 id="include-using-37"><a class="header" href="#include-using-37">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/math/sqrt&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="subtract-flowstdlibmathsubtract"><a class="header" href="#subtract-flowstdlibmathsubtract">Subtract (//flowstdlib/math/subtract)</a></h2>
<p>Subtract one input from another to produce a new output</p>
<h3 id="definition-39"><a class="header" href="#definition-39">Definition</a></h3>
<pre><code class="language-toml">function = &quot;subtract&quot;
source = &quot;subtract.rs&quot;
docs = &quot;subtract.md&quot;
type = &quot;rust&quot;

[[input]]
name = &quot;i1&quot; # - first input of type `Number`
type = &quot;number&quot;

[[input]]
name = &quot;i2&quot; # - second input of type `Number`
type = &quot;number&quot;

[[output]]
type = &quot;number&quot; # - `i1` minus `i2` of type `Number`
</code></pre>
<h3 id="include-using-38"><a class="header" href="#include-using-38">Include using</a></h3>
<pre><code class="language-toml">[[process]]
source = &quot;lib://flowstdlib/math/subtract&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-samples"><a class="header" href="#flow-samples">Flow Samples</a></h1>
<p>This crate contains a number of sample 'flows' that have been developed during the development
of the compiler and the run-time to drive the project development and demonstrate it working. </p>
<p>They also serve as a type of regression test to make sure we don't break any of the 
semantics that the samples rely on.</p>
<p>They range from the extremely simple &quot;hello-world&quot; example to more complex ones like generation of
a fibonacci series or a mandlebrot set image.</p>
<h2 id="structure-of-each-sample"><a class="header" href="#structure-of-each-sample">Structure of each sample</a></h2>
<p>Each sample directory contains:</p>
<ul>
<li>A <code>DESCRIPTION.md</code> file that:
<ul>
<li>describes what the <code>Flow</code> does</li>
<li>lists the features of <code>flow</code> that this sample uses and demonstrates</li>
</ul>
</li>
<li>A <code>root.toml</code> file that is the root file of the flow description</li>
<li>Files used in the automated testing of each sample:
<ul>
<li><code>test_arguments.txt</code> the arguments to be passed to the flow when running it</li>
<li><code>test_input.txt</code> the input supplied to the flow when running it</li>
<li><code>expected_output.txt</code> the output that the flow is expected to produce when invoked with 
<code>text_arguments.txt</code> and input <code>test_input.txt</code></li>
</ul>
</li>
</ul>
<h2 id="compiling-the-samples"><a class="header" href="#compiling-the-samples">Compiling the Samples</a></h2>
<p>The samples set has now been converted to a rust crate with a custom build script.</p>
<p>There is no dependency declared in Cargo.toml on the other crates (as you cannot currently declare a
dependency on a binary, just a lib), but in order to build, test and run this crate/folder you will need <code>flowc</code>
and <code>flowr</code> installed and on <code>$PATH</code> in order for build scripts to find them.</p>
<p>Using <code>cargo build -p flowsamples</code> causes the build script to run, and it compiles in-place the samples
using the <code>flowc</code> compiler.</p>
<h2 id="running-the-samples"><a class="header" href="#running-the-samples">Running the Samples</a></h2>
<p>Using <code>cargo run -p flowsamples</code> causes the sample runner in main.rs to run. It looks for sub-folders in
the samples folder and then executes the sample within. </p>
<p>When running them, it uses:</p>
<ul>
<li>test.arguments - arguments passed to the flow on the command line when executing it</li>
<li>test.input - test input to send to the sample flow using STDIN</li>
</ul>
<p>The output is sent to standard output.</p>
<p>To run a specific sample only use <code>cargo run -p flowsamples {sample-name}</code></p>
<h2 id="testing-the-samples"><a class="header" href="#testing-the-samples">Testing the Samples</a></h2>
<p>You can test all samples by using <code>cargo test -p flowsamples</code>,
it will run each one in turn with the pre-defined arguments and standard input.</p>
<p>It also gathers the standard output, standard error and files generated and checks for correctness 
by comparing them to previously generated content distributed with the package.</p>
<ul>
<li>If there is any standard error found in the file test.err then the test will fail.</li>
<li>If there is no standard error then it compares standard output captured in test.output to expected.output
and fails if there is a difference.</li>
<li>If an expected.file exists then it compares it to file output in test.file and fails if there is any 
difference with the expected file.</li>
</ul>
<pre><code>cargo test -p flowsamples 
    Finished test [unoptimized + debuginfo] target(s) in 0.11s
     Running target/debug/deps/samples-9e024e2c420db146

running 16 tests
test test::test_all_samples ... ignored
test test::test_args ... ok
test test::test_arrays ... ok
test test::test_factorial ... ok
test test::test_fibonacci ... ok
test test::test_hello_world ... ok
test test::test_mandlebrot ... ok
test test::test_matrix_mult ... ok
test test::test_pipeline ... ok
test test::test_prime ... ok
test test::test_primitives ... ok
test test::test_sequence ... ok
test test::test_sequence_of_sequences ... ok
test test::test_reverse_echo ... ok
test test::test_router ... ok
test test::test_tokenizer ... ok

test result: ok. 15 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out
</code></pre>
<p>NOTE: Until multiple instances of the client/server pair for running flows can be run at once, we 
need to restrict the test framework to only run one test at a time, otherwise by default it will run
multiple tests at once, and some will fail.</p>
<p>NOTE: At the moment, to make the progress more visible, each sample has a test manually added to it
in <code>samples/main.rs</code>, so for a new sample a test needs to be added by the author.</p>
<p>To test just one sample use <code>cargo test -p flowsamples {test-name}</code></p>
<pre><code>cargo test -p flowsamples test_factorial
    Finished test [unoptimized + debuginfo] target(s) in 0.12s
     Running target/debug/deps/samples-9e024e2c420db146

running 1 test
test test::test_factorial ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 15 filtered out
</code></pre>
<h2 id="default-workspace-member-crate"><a class="header" href="#default-workspace-member-crate">Default workspace member crate</a></h2>
<p>The <code>samples</code> crate is one of the <code>default-members</code> of the <code>flow</code> workspace project, so it is used if no 
particular package is supplied, thus the samples can also be built and run using:</p>
<ul>
<li><code>cargo build</code> : compile the samples using <code>flowc</code></li>
<li><code>cargo run</code>   : run the samples using <code>flowr</code></li>
<li><code>cargo test</code>  : run the samples using <code>flowr</code> and check the generated output is correct</li>
</ul>
<p>As other <code>default-members</code> are added to the workspace over time, those commands may do other things, so
just be aware that if you only want to run the samples the <code>-p samples</code> option above will be safer.</p>
<h2 id="flowsamples-executable"><a class="header" href="#flowsamples-executable"><code>flowsamples</code> executable</a></h2>
<p>There is also an executable (<code>bin</code> or binary) installed with the library called <code>flowsamples</code> that if run
without any arguments will run all the samples. You can supply it the name of a sample (the name of the folder
under <code>samples</code> where the sample is) to run just that one sample.</p>
<h2 id="developing-a-new-sample"><a class="header" href="#developing-a-new-sample">Developing a new sample</a></h2>
<p>To develop a new sample, just create a new folder under 'samples' with your sample name. </p>
<p>Add the root.toml and any other included flows and describe them.</p>
<p>Add a DESCRIPTION.md file that describes what the sample does and what features of flow it uses.</p>
<p>Add an entry in the guide's &quot;samples&quot; section that will include the DESCRIPTION.md file above.</p>
<h2 id="features-1"><a class="header" href="#features-1">features</a></h2>
<p><code>flowsamples</code> has no features to enable</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="args"><a class="header" href="#args">args</a></h1>
<h1 id="description-1"><a class="header" href="#description-1">Description</a></h1>
<p>A flow that shows how arguments can be passed into a flow when executed and are available to functions at run-time.</p>
<h1 id="root"><a class="header" href="#root">Root</a></h1>
<p><a href="flowsamples/args/root.dot.svg" target="_blank"><img src="flowsamples/args/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used"><a class="header" href="#features-used">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li><code>context</code> Functions used (`stdio/stdout``)</li>
<li>Reduced syntax so that <code>alias</code> of referenced processes default to their names (<code>get</code> and <code>stdout</code>)</li>
<li>Selecting a specific indexed entry of an <code>array</code> output</li>
<li>Library Flows used (<code>args/get</code> from <code>flowstdlib</code>)</li>
<li>Connections between functions</li>
</ul>
<h1 id="functions-diagram"><a class="header" href="#functions-diagram">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/args/functions.dot.svg" target="_blank"><img src="flowsamples/args/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">arrays</a></h1>
<h1 id="description-2"><a class="header" href="#description-2">Description</a></h1>
<p>Sample to show the capabilities of:</p>
<ul>
<li>
<p>gathering a stream of outputs of type Object to an input of type Object, of a specified size. 
This is done by the P2 'composer' (<code>ComposeArray</code>) function.</p>
</li>
<li>
<p>Decomposing an output of type array of objects to a stream of objects. This is done by the runtime when it sees
a connection from an array of Type to Type.</p>
</li>
<li>
<p>P1 - sequence - generates a stream of outputs of type number</p>
</li>
<li>
<p>P2 - composer - input of type Number of width 4, output of type array of number</p>
</li>
<li>
<p>P3 - adder    - input of type Number and output of type Number, adding 1 in the process</p>
</li>
<li>
<p>P4 - print    - print the output (the original sequence with '1' added to each number)</p>
</li>
</ul>
<p>This sample (with default settings on a multi-core machine) shows parallelism of the add function, dispatching
multiple jobs for it in parallel as the array of number output from the previous process is decomposed, creating
a job for each Number. You can see this by using the <code>-j</code> option of the runtime to limit the number of outstanding
jobs and the <code>-m</code> options to dump metrics after execution. The &quot;Max Number of Parallel Jobs&quot; should be similar or
greater than 4, which is the size of the array of numbers formed.</p>
<h1 id="root-1"><a class="header" href="#root-1">Root</a></h1>
<p><a href="flowsamples/arrays/root.dot.svg" target="_blank"><img src="flowsamples/arrays/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-1"><a class="header" href="#features-used-1">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Setting initial value of a Function's inputs</li>
<li>Multiple connections into and out of functions and values</li>
<li>Library Functions</li>
<li>Implicit conversion between arrays of objects and objects done by run-time</li>
<li>Explicit conversion between a stream of objects and an array using the <code>compose_array</code> library function</li>
</ul>
<h1 id="functions-diagram-1"><a class="header" href="#functions-diagram-1">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/arrays/functions.dot.svg" target="_blank"><img src="flowsamples/arrays/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorial"><a class="header" href="#factorial">factorial</a></h1>
<h1 id="description-3"><a class="header" href="#description-3">Description</a></h1>
<p>A flow that calculates the factorial of a number and prints it out on <code>stdout</code>.</p>
<h1 id="root-2"><a class="header" href="#root-2">Root</a></h1>
<p><a href="flowsamples/factorial/root.dot.svg" target="_blank"><img src="flowsamples/factorial/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-2"><a class="header" href="#features-used-2">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Connections between functions</li>
<li>Loop-back connections to accumulate a multiplication result</li>
<li>Initializing function inputs with values, once and constantly</li>
<li>Multiple connections into and out of functions</li>
<li>Library Functions <code>to_json</code>, <code>multiply</code>, <code>subtract</code> from <code>flowstdlib</code></li>
<li>Library Functions <code>tap</code>, <code>compare</code> from <code>flowstdlib</code></li>
<li>Use of aliases to refer to functions with different names inside a flow</li>
</ul>
<h1 id="functions-diagram-2"><a class="header" href="#functions-diagram-2">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/factorial/functions.dot.svg" target="_blank"><img src="flowsamples/factorial/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fibonacci"><a class="header" href="#fibonacci">fibonacci</a></h1>
<h1 id="description-4"><a class="header" href="#description-4">Description</a></h1>
<p>A flow that generates a Fibonacci series of numbers and prints it out on <code>stdout</code>.</p>
<h1 id="root-diagram"><a class="header" href="#root-diagram">Root Diagram</a></h1>
<p><a href="flowsamples/fibonacci/root.dot.svg" target="_blank"><img src="flowsamples/fibonacci/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-3"><a class="header" href="#features-used-3">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Child flow described separately, with named outputs to parent flow</li>
<li>Connections between Input/Outputs of parent/child flows</li>
<li>Setting initial value of a Value at startup</li>
<li>Multiple connections into and out of functions and values</li>
<li><code>context</code> Functions used (<code>stdout</code>)</li>
<li>Library Functions used (<code>buffer</code> and <code>add</code> from <code>flowstdlib</code>)</li>
<li>Use of aliases to refer to functions with different names inside a flow</li>
<li>Connections between flows, functions and values</li>
</ul>
<h1 id="functions-diagram-3"><a class="header" href="#functions-diagram-3">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/fibonacci/functions.dot.svg" target="_blank"><img src="flowsamples/fibonacci/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">hello-world</a></h1>
<h1 id="description-5"><a class="header" href="#description-5">Description</a></h1>
<p>A simple flow that prints &quot;Hello World!&quot; on <code>stdout</code></p>
<h1 id="root-diagram-1"><a class="header" href="#root-diagram-1">Root Diagram</a></h1>
<p><a href="flowsamples/hello-world/root.dot.svg" target="_blank"><img src="flowsamples/hello-world/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-4"><a class="header" href="#features-used-4">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Library Functions used (<code>stdout</code> from <code>flowstdlib</code>)</li>
</ul>
<h1 id="functions-diagram-4"><a class="header" href="#functions-diagram-4">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/hello-world/functions.dot.svg" target="_blank"><img src="flowsamples/hello-world/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mandlebrot"><a class="header" href="#mandlebrot">mandlebrot</a></h1>
<p>Render a mandlebrot set into an image file, with the output image size and imaginary number coordinate 
space configured via input parameters.</p>
<p>The pre-configured test (input arguments in <a href="flowsamples/mandlebrot/test.args">test.args</a>) renders a very small mandlebrot 
set (20x15 pixels) in order to keep the test running time time short and be able to use in in CI runs.</p>
<p><a href="flowsamples/mandlebrot/expected.file" target="_blank"><img src="flowsamples/mandlebrot/expected.file" width="100" height="75"></a></p>
<h1 id="description-6"><a class="header" href="#description-6">Description</a></h1>
<p>Notably, there is also a standalone rust project in the <code>project</code> (<a href="flowsamples/mandlebrot/project/Cargo.toml">Cargo manifest</a>) folder.
The functions are used in the rust program that is built and also made available as functions to the 
Flow project that is described in the toml files - showing how native code can live alongside and be used by 
the flow.</p>
<h1 id="root-diagram-2"><a class="header" href="#root-diagram-2">Root Diagram</a></h1>
<p><a href="flowsamples/mandlebrot/root.dot.svg" target="_blank"><img src="flowsamples/mandlebrot/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-5"><a class="header" href="#features-used-5">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>subflow described separately, with named outputs to parent flow</li>
<li>Connections between Input/Outputs of parent/child flows</li>
<li>Setting initial value of a function with a <code>Once</code> initializer</li>
<li>Multiple connections into and out of functions and sub-flows</li>
<li>Library Functions used to convert Number to String and to add numbers</li>
<li>Use of aliases to refer to functions with different names inside a flow</li>
<li>Connections between flows, functions and values</li>
<li><code>flowr</code> <code>context function</code> used to render output to an <a href="flowsamples/mandlebrot/../../flowr/src/cli/image/image_buffer.html">Image Buffer</a></li>
<li><code>provided functions</code> in rust that get compiled to WASM and then loaded and executed by the runtime</li>
</ul>
<h1 id="functions-diagram-5"><a class="header" href="#functions-diagram-5">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/mandlebrot/functions.dot.svg" target="_blank"><img src="flowsamples/mandlebrot/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<h1 id="subflows-and-functions-description"><a class="header" href="#subflows-and-functions-description">SubFlows and Functions Description</a></h1>
<ul>
<li>Subflow <a href="flowsamples/mandlebrot/parse_args.toml">parse_args</a> reads the argument passed to the flow and outputs the filename to render to, 
the size (width, height in <code>array/number</code>) and bounds of coordinate space (an array of 2 imaginary numbers,
where an imaginary number is two numbers, so expressed as <code>array/array/number</code>) to calculate the set for</li>
<li>Subflow <a href="flowsamples/mandlebrot/generate_pixels.toml">generate pixels</a> that enumerates the 2D array of pixels to calculate, producing
&quot;a stream&quot; of pixels (x, y coordinates) to be used to calculate the appropriate value for that pixel.</li>
<li>Subflow <a href="flowsamples/mandlebrot/render.toml">render</a> that uses the functions below to take the pixels, calculate it's location
in the 2D imaginary space, calculate the value in the set for that point and then render value at the pixel
in the image buffer.
<ul>
<li>Function <a href="flowsamples/mandlebrot/pixel_to_point/pixel_to_point.html">pixel to point</a> to calculate the corresponding location
in the 2D imaginary coordinate system for each pixel</li>
<li>Function <a href="flowsamples/mandlebrot/escapes/escapes.html">escapes</a> to calculate the appropriate value (using the core mandlebrot algorithm) for
each pixel.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escapes"><a class="header" href="#escapes">Escapes</a></h1>
<p>Try to determine if 'c' is in the Mandelbrot set, using at most 'limit' iterations to decide if 'c' is not a member, 
return 'Some(i)', where 'i' is the number of iterations it took for 'c' to leave the circle of radius two centered on the origin.</p>
<p>If 'c' seems to be a member (more precisely, if we reached the iteration limit without being able to prove that 'c' 
is not a member) return 'None'</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pixel-to-point-function"><a class="header" href="#pixel-to-point-function">Pixel To Point function</a></h1>
<p>Given the row and column of a pixel in the output image, return the corresponding point on the complex plane.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorial-1"><a class="header" href="#factorial-1">factorial</a></h1>
<h1 id="description-7"><a class="header" href="#description-7">Description</a></h1>
<p>A flow that calculates the matrix product of two matrices.</p>
<h1 id="root-diagram-3"><a class="header" href="#root-diagram-3">Root Diagram</a></h1>
<p><a href="flowsamples/matrix_mult/root.dot.svg" target="_blank"><img src="flowsamples/matrix_mult/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-6"><a class="header" href="#features-used-6">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Connections between functions</li>
<li>Loop-back connections to accumulate an array, used to gather Numbers into array/number and then array/number into
array/array/number (i.e. Matrix)</li>
<li>Initializing function inputs with values, once and constantly</li>
<li>Multiple connections into and out of functions</li>
<li>Library Functions <code>to_json</code>, <code>multiply</code>, <code>subtract</code> from <code>flowstdlib</code></li>
<li>Library Functions <code>tap</code>, <code>compare</code> from <code>flowstdlib</code></li>
<li>Use of aliases to refer to functions with different names inside a flow</li>
<li>Automatic array decomposing into the elements the array holds when target function input does not accept the array type</li>
</ul>
<h1 id="functions-diagram-6"><a class="header" href="#functions-diagram-6">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/matrix_mult/functions.dot.svg" target="_blank"><img src="flowsamples/matrix_mult/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipeline"><a class="header" href="#pipeline">pipeline</a></h1>
<h1 id="description-8"><a class="header" href="#description-8">Description</a></h1>
<p>A sample that shows a simple &quot;pipeline flow&quot; with a number of functions organized into a
pipeline. When supplied with a &quot;stream&quot; of inputs, multiple functions are able to run in
parallel utilizing more than one core on the machine.</p>
<p>Using command line options (-j, -t) the flow can be invoked with just one worker thread and it 
becomes sequential. The metrics of how many jobs were able to be processed in parallel can
be viewed using the -m command line option.</p>
<h1 id="root-diagram-4"><a class="header" href="#root-diagram-4">Root Diagram</a></h1>
<p><a href="flowsamples/pipeline/root.dot.svg" target="_blank"><img src="flowsamples/pipeline/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-7"><a class="header" href="#features-used-7">Features Used</a></h1>
<ul>
<li>Rot Flow</li>
<li>Setting initial value of a Value at startup</li>
<li>Multiple connections into and out of functions and values</li>
<li>Library Functions used from <code>flowstdlib</code></li>
<li>Use of aliases to refer to functions with different names</li>
<li>Connections between functions and values</li>
<li>Referring to a function's input by name in connections</li>
</ul>
<h1 id="functions-diagram-7"><a class="header" href="#functions-diagram-7">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/pipeline/functions.dot.svg" target="_blank"><img src="flowsamples/pipeline/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime"><a class="header" href="#prime">prime</a></h1>
<p>WIP</p>
<h1 id="description-9"><a class="header" href="#description-9">Description</a></h1>
<p>A flow that finds prime numbers upto the maximum specified in the input arguments</p>
<h1 id="root-diagram-5"><a class="header" href="#root-diagram-5">Root Diagram</a></h1>
<p><a href="flowsamples/prime/root.dot.svg" target="_blank"><img src="flowsamples/prime/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-8"><a class="header" href="#features-used-8">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Sub-flows</li>
<li>Value (with an initial value set)</li>
<li>Constant Value</li>
<li>Arguments parsing for the execution</li>
<li>Constant Value used</li>
<li>Connections between functions</li>
<li>Library Functions used
<ul>
<li><code>Args</code> to parse arguments</li>
<li><code>sequence</code> to generate a sequence of numbers</li>
<li><code>divide</code> to divide two numbers</li>
<li><code>compare</code> function to produce outputs based on comparing two input values</li>
<li><code>switch</code> function to stop or pass a data flow based on another one</li>
<li><code>ToString</code> to convert Numbers to Strings</li>
<li><code>stdout</code> to print a String to standard output</li>
</ul>
</li>
</ul>
<h1 id="functions-diagram-8"><a class="header" href="#functions-diagram-8">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/prime/functions.dot.svg" target="_blank"><img src="flowsamples/prime/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitives"><a class="header" href="#primitives">primitives</a></h1>
<h1 id="description-10"><a class="header" href="#description-10">Description</a></h1>
<p>A flow that takes a value and a constant and adds them, and then takes the result and adds 
it to the constant again and then printed the final value to stdout. It also uses the switch function
to stop a flow with a false value, and compares the result of the add to a value and print out to stdout
if it is greater or equal to it.</p>
<p>The purpose is not to do anything useful, but just to show the use of and stress the semantics 
of a number of the primitives.</p>
<h1 id="root-diagram-6"><a class="header" href="#root-diagram-6">Root Diagram</a></h1>
<p><a href="flowsamples/primitives/root.dot.svg" target="_blank"><img src="flowsamples/primitives/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-9"><a class="header" href="#features-used-9">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Library Functions used (<code>add</code> and <code>stdout</code> from <code>flowstdlib</code>)</li>
<li>Value used (with an initial value set)</li>
<li>Constant Value used</li>
<li>Connections between functions</li>
<li>Two functions of the same name in the same flow, distinguished by <code>alias</code></li>
<li><code>switch</code> function to stop or pass a data flow based on another one</li>
<li><code>compare</code> function to produce outputs based on comparing two input values</li>
</ul>
<h1 id="functions-diagram-9"><a class="header" href="#functions-diagram-9">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/primitives/functions.dot.svg" target="_blank"><img src="flowsamples/primitives/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse-echo"><a class="header" href="#reverse-echo">reverse-echo</a></h1>
<h1 id="description-11"><a class="header" href="#description-11">Description</a></h1>
<p>Trivial flow that takes a line on <code>stdin</code>, reverses it and then prints it on <code>stdout</code></p>
<h1 id="root-diagram-7"><a class="header" href="#root-diagram-7">Root Diagram</a></h1>
<p><a href="flowsamples/reverse-echo/root.dot.svg" target="_blank"><img src="flowsamples/reverse-echo/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-10"><a class="header" href="#features-used-10">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Library Functions used (<code>stdin</code> and <code>stdout</code> from <code>flowstdlib</code>)</li>
<li>Custom function (in rust) with a structure on the output with sub-elements</li>
<li>Connections between functions</li>
<li>Connections from sub-elements of a function's output</li>
<li>Function with single input (stdout) not requiring input name</li>
</ul>
<h1 id="functions-diagram-10"><a class="header" href="#functions-diagram-10">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/reverse-echo/functions.dot.svg" target="_blank"><img src="flowsamples/reverse-echo/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="router"><a class="header" href="#router">router</a></h1>
<h1 id="description-12"><a class="header" href="#description-12">Description</a></h1>
<p>This sample implements the algorithm (as described here https://github.com/andrewdavidmackenzie/router) for
calculating the shortest route from a start-point to an end-point through a simplified road 
network.</p>
<p><img src="flowsamples/router/LHR_to_LON.png" alt="Road route London Heathrow to City Center" /></p>
<h1 id="root-diagram-8"><a class="header" href="#root-diagram-8">Root Diagram</a></h1>
<p><a href="flowsamples/router/root.dot.svg" target="_blank"><img src="flowsamples/router/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-11"><a class="header" href="#features-used-11">Features Used</a></h1>
<ul>
<li>The selection of a single Value from an array of values that is one of a number of outputs (not the only 
output). This involves selecting the structure from the output by route, and then the value from that by index. </li>
</ul>
<h1 id="functions-diagram-11"><a class="header" href="#functions-diagram-11">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/router/functions.dot.svg" target="_blank"><img src="flowsamples/router/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence"><a class="header" href="#sequence">sequence</a></h1>
<h1 id="description-13"><a class="header" href="#description-13">Description</a></h1>
<p>A flow that generates a sequence of output numbers in a range between two input numbers</p>
<h1 id="root-diagram-9"><a class="header" href="#root-diagram-9">Root Diagram</a></h1>
<p><a href="flowsamples/sequence/root.dot.svg" target="_blank"><img src="flowsamples/sequence/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-12"><a class="header" href="#features-used-12">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Initial value setting on flow inputs</li>
<li>Connections between functions</li>
<li>Library function <code>join</code> used</li>
<li>Library subflow <code>sequence</code> used</li>
<li>`contextc Functions used
<ul>
<li><code>stdout</code> to print a String to standard output</li>
</ul>
</li>
</ul>
<h1 id="functions-diagram-12"><a class="header" href="#functions-diagram-12">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/sequence/functions.dot.svg" target="_blank"><img src="flowsamples/sequence/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="range-of-ranges"><a class="header" href="#range-of-ranges">range-of-ranges</a></h1>
<h1 id="description-14"><a class="header" href="#description-14">Description</a></h1>
<p>A flow that generates a sequence of numbers, and for each of those numbers it generates a sequence
from 1 upto the number from the sequence.</p>
<p>This is intended as a test case for having nested flows.</p>
<h1 id="root-diagram-10"><a class="header" href="#root-diagram-10">Root Diagram</a></h1>
<p><a href="flowsamples/sequence-of-sequences/root.dot.svg" target="_blank"><img src="flowsamples/sequence-of-sequences/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-13"><a class="header" href="#features-used-13">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Library Functions used (<code>stdout</code> from <code>flowstdlib</code>)</li>
<li>Library Flows used (<code>sequence</code> from <code>flowstdlib</code>)</li>
<li>Connections between functions</li>
</ul>
<h1 id="functions-diagram-13"><a class="header" href="#functions-diagram-13">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/sequence-of-sequences/functions.dot.svg" target="_blank"><img src="flowsamples/sequence-of-sequences/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokenizer"><a class="header" href="#tokenizer">tokenizer</a></h1>
<h1 id="description-15"><a class="header" href="#description-15">Description</a></h1>
<p>Sample to show the possible parallelization (depending on the runtime implementation) of splitting a string into
tokens using the string splitter function from the flowstdlib.</p>
<h1 id="root-diagram-11"><a class="header" href="#root-diagram-11">Root Diagram</a></h1>
<p><a href="flowsamples/tokenizer/root.dot.svg" target="_blank"><img src="flowsamples/tokenizer/root.dot.svg"></a></p>
<p>Click image to navigate flow hierarchy.</p>
<h1 id="features-used-14"><a class="header" href="#features-used-14">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Setting initializer of a Function's input with a constant initializer</li>
<li>Library Functions</li>
<li>Iteration (possibly in parallel) via feedback of partial output values back to the same funtion's input.</li>
<li>Implicit conversion between arrays of string and string done by run-time, in feedbak loop to the same process</li>
</ul>
<h1 id="functions-diagram-14"><a class="header" href="#functions-diagram-14">Functions Diagram</a></h1>
<p>This diagram shows the exploded diagram of all functions in all flows, and their connections.
<a href="flowsamples/tokenizer/functions.dot.svg" target="_blank"><img src="flowsamples/tokenizer/functions.dot.svg"></a></p>
<p>Click image to view functions graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="developing-flow"><a class="header" href="#developing-flow">Developing flow</a></h2>
<h3 id="supported-operating-systems"><a class="header" href="#supported-operating-systems">Supported Operating Systems</a></h3>
<p>The CI tests for 'flow' run on Mac OS X and Linux. Others may well work as rust projects are pretty 
portable but I develop on Mac OS X and don't know the status on other OS.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pre-requisites-required-to-build-and-test"><a class="header" href="#pre-requisites-required-to-build-and-test">Pre-requisites required to build and test</a></h2>
<p>These are the pre-requisites that are required to build and test 'flow':</p>
<ul>
<li>rust toolchain (<code>rustup</code>, <code>cargo</code>, <code>rustc</code>, etc )
<ul>
<li>with <code>wasm32-unknown-unknown</code> target for compiling to wasm</li>
<li><code>clippy</code> for checking coding best practices</li>
</ul>
</li>
<li><code>zmq</code> (Zero Message Queue) library</li>
<li><code>graphviz</code> utilities for automatic generation of SVG files for docs</li>
</ul>
<p>For building the guide:
<code>mdbook</code> and the <code>mdbook-linkcheck</code> plug-in</p>
<h2 id="installing-pre-requisites"><a class="header" href="#installing-pre-requisites">Installing pre-requisites</a></h2>
<p>You have to install rustup, cargo and rust toolchain yourself.
I decided to stop short of futzing with people's installed toolchains.</p>
<p>There is a Makefile target <code>config</code> that will install the other dependencies:</p>
<ul>
<li><code>make config</code></li>
</ul>
<p>That will add the <code>wasm32-unknown-unknown</code> target, <code>clippy</code>, <code>graphviz</code>, <code>mdbook</code> and <code>mdbook-linkcheck</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-flow"><a class="header" href="#building-flow">Building <code>flow</code></a></h1>
<h2 id="install-pre-requisites-and-build"><a class="header" href="#install-pre-requisites-and-build">Install Pre-requisites and Build</a></h2>
<p>You need <a href="https://git-scm.com">Git</a> to clone the repo.</p>
<h3 id="clone-the-repo"><a class="header" href="#clone-the-repo">Clone the repo</a></h3>
<p>From your command line:</p>
<p><code>git clone https://github.com/andrewdavidmackenzie/flow.git</code></p>
<h3 id="install-build-tools"><a class="header" href="#install-build-tools">Install build tools</a></h3>
<p>You need <code>make</code> and a rust toolchain (cargo, rustc, clippy) to build from source
(I suggest using <a href="https://rustup.rs/">rustup</a>).</p>
<p>Once you have those, you can install the remaining pre-requisites using:</p>
<p><code>make config</code></p>
<p>These include libraries like <code>ssl</code> and tools like <code>mdbook</code>, <code>mdbook-linkcheck</code> and <code>graphviz</code> to build the docs.</p>
<p>The <code>make config</code> target should install them all for you. It should work on <code>macos</code> and <code>linux</code> variants using <code>apt-get</code>
or <code>yum</code> package managers (PRs to Makefile are welcome for other linux package managers).</p>
<h3 id="build-and-test"><a class="header" href="#build-and-test">Build and test</a></h3>
<p>To build and test, including building and testing docs and running the samples and checking their output is correct:</p>
<p><code>make</code></p>
<p><strong>NOTE</strong>
The first time you build, it will take a long time. This is due to a large number of function implementations
in the <code>flowstdlib</code> standard library - each being compiled to WASM as individual projects. After the first build,
dependencies are tracked by the <code>flowc</code> compiler and implementations are only re-compiled when required.</p>
<h2 id="make-docs-or-guide-changes"><a class="header" href="#make-docs-or-guide-changes">Make docs or guide changes</a></h2>
<p>After a PR is merged, and the build of <code>master</code> succeeds, the guide is rebuilt and the resulting html is deployed for
viewing <a href="http://andrewdavidmackenzie.github.io/flow/">here</a></p>
<h2 id="project-components-and-structure-1"><a class="header" href="#project-components-and-structure-1">Project components and structure</a></h2>
<p>The Project is structured into a number of rust crates that form part of a rust cargo &quot;workspace&quot;.</p>
<p>Currently, two binaries are built: <code>flowc</code> the flow compiler and <code>flowr</code> the flow runner.</p>
<p>See the <a href="docs/developing/../introduction/structure.html">Project Components and Structure section</a> of the Guide for more details.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>I organize all issues in a <a href="https://github.com/andrewdavidmackenzie/flow/projects/2">Github Project</a>
and chose things to work on from the &quot;Next&quot; column. I have only marked a couple of issues with &quot;help wanted&quot; label
but I can do more if there is interest. If in doubt reach out to me by email, or GitHub issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="crates-in-the-flow-project"><a class="header" href="#crates-in-the-flow-project">Crates in the flow project</a></h2>
<p>The flow project is split into a number of different crates for a number of reasons:</p>
<ul>
<li>proc macros need to be in their own crate</li>
<li>sharing of structures and code across compiler and runner crates</li>
<li>desire to separate core functionality in libraries from CLI binaries and enable UI applications using only the 
libraries</li>
<li>provide CLI versions of compiler and runner</li>
<li>avoid cyclic dependencies between parts</li>
<li>allow to compile optionally without some features, not using code in a crate</li>
<li>separate library implementation from compiler and runner</li>
</ul>
<p>The following sections provide a brief description of the crates in the project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flowcore"><a class="header" href="#flowcore"><code>flowcore</code></a></h1>
<p>See also: <a href="http://andrewdavidmackenzie.github.io/flow/code/doc/flowcore/index.html">Code docs</a></p>
<p><code>flowcore</code> is a library of structs and traits related to <code>flow</code> that are shared between multiple
crates in the <code>flow</code>project.</p>
<h2 id="implementation-trait"><a class="header" href="#implementation-trait"><code>Implementation</code> trait</a></h2>
<p>This is a trait that implementations of flow 'functions' must implement in order for them to be invoked
by the flowrlib (or other) run-time library.</p>
<p>An example of a function implementing the <code>Implementation</code> trait can be found in the
docs for <a href="http://andrewdavidmackenzie.github.io/flow/code/doc/flowcore/trait.Implementation.html">Implementation</a></p>
<h2 id="provider"><a class="header" href="#provider"><code>Provider</code></a></h2>
<p>This implements a <code>content provider</code> that resolves URLs and then gets the content of the url.</p>
<h2 id="features-2"><a class="header" href="#features-2">Features</a></h2>
<p><code>flowcore</code> crate supports a number of &quot;features&quot; for conditional compiling with more or less features.</p>
<h2 id="features-3"><a class="header" href="#features-3">features</a></h2>
<p>These are the conditionally compiled features of <code>flowcore</code>:</p>
<ul>
<li>default - none are activated by default</li>
<li>context - makes this crate aware of the flow context functions or not</li>
<li>debugger - feature to add the debugger</li>
<li>online_tests - run any tests activated by this feature</li>
<li>meta_provider - include the meta provider for resolving &quot;lib://&quot; and &quot;context://&quot; Urls</li>
<li>file_provider - include a provider to fetch content from the file system</li>
<li>http_provider - include a provider to fetch content from the web</li>
</ul>
<p>Examples</p>
<ul>
<li><code>flowrlib</code> library crate compiles <code>flowcore</code> activating the &quot;file_provider&quot;, &quot;http_provider&quot;,
&quot;context&quot; and &quot;meta_provider&quot; features</li>
<li><code>flowr</code> compiled <code>flowcore</code> activating the &quot;context&quot; feature as it provides <code>context functions</code>. It has a 
number of features that, if activated, active corresponding features in <code>flowcore</code> (<code>flowr</code> &quot;debugger&quot;
feature actives &quot;flowcore/debugger&quot; feature.) and it depends on <code>flowrlib</code> (above) that in turn activates
features</li>
<li><code>flowrex</code> compiles <code>flowcore</code> with the default set of features (which is the minimal set in the case
of <code>flowcore</code> as it does not provide ant <code>context functions</code> (&quot;context&quot; feature), nor does it coordinate flow
running and provide a debugger (&quot;debugger&quot; feature), nor does it have the need for running &quot;online_tests&quot;,
and lastly it does not fetch content via any of the various &quot;providers&quot; (&quot;meta_provider&quot;, &quot;file_provider&quot;,
and &quot;http_provider&quot; features).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flowmacro"><a class="header" href="#flowmacro"><code>flowmacro</code></a></h1>
<p>See also: <a href="http://andrewdavidmackenzie.github.io/flow/code/doc/flowmacro/index.html">Code docs</a></p>
<p><code>flow_function</code> is a proc macro to be used on the structure that provides an implementation for a function (by 
implementing the <code>FlowImpl</code> trait), so that when compiled for the <code>wasm32</code> target, code is inserted to help read 
the inputs, help form the outputs and allocate memory (<code>alloc</code>) as well as serialize and deserialize the data 
passed across the native/wasm boundary.</p>
<h2 id="features-4"><a class="header" href="#features-4">Features</a></h2>
<p><code>flowmacro</code> has no features</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flowrlib"><a class="header" href="#flowrlib"><code>flowrlib</code></a></h1>
<p>See also: <a href="http://andrewdavidmackenzie.github.io/flow/code/doc/flowrlib/index.html">Code docs</a></p>
<p>This is the rust run-time library for flow execution. This will be linked with other code to produce a flow
runner, such as the <code>flowr</code> command line runner.</p>
<p>It is responsible for reading a flow definition in a <code>Manifest</code> file, loading the required libraries 
from <code>LibraryManifest</code> files and then coordinating the execution by dispatching <code>Jobs</code> to be executed 
by <code>Function</code> <code>Implementations</code>, providing them the <code>Inputs</code> required to run and gathering the <code>Outputs</code> produced 
and passing those <code>Outputs</code> to other connected <code>Functions</code> in the network of <code>Functions</code>.</p>
<h2 id="features-5"><a class="header" href="#features-5">features</a></h2>
<p>These are the conditionally compiled features of <code>flowrlib</code>:</p>
<ul>
<li>default - none are activated by default</li>
<li>submission - include the ability to receive a submission of a flow for execution</li>
<li>context - makes this crate aware of the flow context functions or not</li>
<li>debugger - feature to add the debugger</li>
<li>metrics - feature for tracking of metrics during execution</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flowr"><a class="header" href="#flowr"><code>flowr</code></a></h1>
<p>See also: <a href="http://andrewdavidmackenzie.github.io/flow/code/doc/flowr/index.html">Code docs</a></p>
<p><code>flowr</code> is a binary run-time for running flows from the CLI built using the <code>flowrlib</code> library.</p>
<p>It handles the execution of <code>Functions</code> forming a <code>Flow</code> according to the defined semantics.</p>
<h2 id="context-functions-1"><a class="header" href="#context-functions-1">Context Functions</a></h2>
<p>The <code>flowr</code> <code>context</code> module implements the context functions that this runtime
provides for flows to interact with the environment it is being run in, such as Standard IO and File System.</p>
<p>These are all impure functions, or functions with side effects, not part of the flow itself.</p>
<p>Those functions are organized into the following modules, each with multiple functions:</p>
<ul>
<li><a href="docs/developing/../../flowr/src/cli/args/args.html">args</a> - used to get arguments that flow was invoked with</li>
<li><a href="docs/developing/../../flowr/src/cli/file/file.html">file</a> - used to interact with the file system</li>
<li><a href="docs/developing/../../flowr/src/cli/image/image.html">image</a> - used to create image files</li>
<li><a href="docs/developing/../../flowr/src/cli/stdio/stdio.html">stdio</a> - used to interact with stdio</li>
</ul>
<h2 id="features-6"><a class="header" href="#features-6">features</a></h2>
<p>These are the conditionally compiled features of <code>flowr</code>:</p>
<ul>
<li>default - &quot;debugger&quot; and &quot;metrics&quot; features are enabled by default</li>
<li>debugger - feature to add the debugger</li>
<li>metrics - feature for tracking of metrics during execution</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flowr-1"><a class="header" href="#flowr-1"><code>flowr</code></a></h1>
<p>See also: <a href="http://andrewdavidmackenzie.github.io/flow/code/doc/flowrex/index.html">Code docs</a></p>
<p><code>flowrex</code> is a binary for the execution of flow jobs, dispatched over the network by <code>flowr</code> or some other
flow runner application that runs a <code>coordinator</code> (via the <code>flowrlib</code> library).</p>
<p>You can find more details about how to use it in running flows in the <a href="docs/developing/../running/distributed.html">distributed</a> section.</p>
<h2 id="features-7"><a class="header" href="#features-7">features</a></h2>
<p>These are the conditionally compiled features of <code>flowr</code>:</p>
<ul>
<li>default - &quot;flowstdlib&quot; (dependency as a feature) to link <code>flowstdlib</code> natively. Deactivating this would
allow use of <code>flowstdlib</code> via it's WASM function implementations (use of <code>-L</code> option required)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flowc"><a class="header" href="#flowc"><code>flowc</code></a></h1>
<p>See also: <a href="http://andrewdavidmackenzie.github.io/flow/code/doc/flowc/index.html">Code docs</a></p>
<p><code>flowc</code> is the &quot;compiler and linker&quot; for flows and flow libraries, although it is not 
very similar to what you might be familiar with as a compiler or linker.</p>
<p>It loads flow definition files, and builds the flow hierarchy reading from referenced
flows/functions and library references, and builds the flow in memory.</p>
<p>Then it connects all functions via data flows through the hierarchy and removes most of the
flow structure leaving a &quot;network of functions&quot; which it then optimizes (removing
unused functions and connections).</p>
<p>It checks that types match and required connections exist. </p>
<p>It also checks for some illegal or cases that would prove problematic at runtime
(specific types of &quot;loops&quot; or contention for a connection)</p>
<p>Lastly it generates a manifest describing the flow, which can be executed by <code>flowr</code>.</p>
<p>It then may (depending on the command line options used) invoke <code>flowr</code> (using cargo to ensure
it is up to date and built).</p>
<p>It is structured as a library with a thin CLI wrapper around it that offers command line arguments
and then uses the library to compile and optionally run the compiled flow.</p>
<h1 id="flowclib"><a class="header" href="#flowclib"><code>flowclib</code></a></h1>
<p>This library contains most of the compilation and linking logic for <code>flowc</code>. </p>
<p>See also: <a href="http://andrewdavidmackenzie.github.io/flow/code/doc/flowclib/index.html">Code docs</a></p>
<h2 id="features-8"><a class="header" href="#features-8">features</a></h2>
<p>These are the conditionally compiled features of the <code>flowc</code> crate:</p>
<ul>
<li>default - The &quot;debugger&quot; feature is enabled by default</li>
<li>debugger - feature to add the debugger</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="test-flows"><a class="header" href="#test-flows">Test flows</a></h2>
<p>These are a number of test flows to exercise specific features and are not intended to be &quot;real world programs&quot; 
or solutions to problems.</p>
<p>They are contained in the <a href="https://github.com/andrewdavidmackenzie/flow/tree/master/flowc/tests/test-flows">flowc/tests/test-flows</a>
folder in the code.</p>
<h3 id="structure-of-each-test"><a class="header" href="#structure-of-each-test">Structure of each test</a></h3>
<p>Each test flow of name 'text-name' is in its own folder, which includes:</p>
<ul>
<li>A <code>test-name.toml</code> file that contains the flow description</li>
<li>Files used in the automated testing of each sample:
<ul>
<li><code>test-name.args</code> the arguments to be passed to the flow when running it</li>
<li><code>test-name.stdin</code> the input supplied to the flow on standard input when running it</li>
<li><code>test-name.expected</code> the output that the flow is expected to produce when invoked with 
<code>test-name.args</code> as command line arguments (via <code>flowr</code>) and <code>test-name.stdin</code> 
sent to standard input</li>
</ul>
</li>
</ul>
<h3 id="execution-of-each-test"><a class="header" href="#execution-of-each-test">Execution of each test</a></h3>
<ul>
<li>The test flow will be compiled by <code>flowc</code> and the manifest generated in a file names <code>test-name.json</code></li>
<li>The <code>test-name.json</code> manifest will be executed by <code>flowr</code>, passing <code>test-name.args</code> as it's arguments
and piping the contents of <code>test-name.stdin</code> to standard input, and standard output of the flow execution will 
be captured.</li>
<li>The standard output will be compared to <code>test-name.expected</code> and if identical the test will pass.
Any differences and the test will fail.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world-simple"><a class="header" href="#hello-world-simple">hello-world-simple</a></h1>
<h1 id="description-16"><a class="header" href="#description-16">Description</a></h1>
<p>The simplest possible &quot;Hello World!&quot; example with 'flow'.</p>
<h1 id="features-used-15"><a class="header" href="#features-used-15">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>A String value that is initialized at start-up</li>
<li>Context Functions used (<code>stdout</code> from <code>context</code>)</li>
<li>A connection between the value and the function</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="line-echo"><a class="header" href="#line-echo">line-echo</a></h1>
<h1 id="description-17"><a class="header" href="#description-17">Description</a></h1>
<p>A trivial flow that takes a line on <code>stdin</code>, and prints it on <code>stdout</code></p>
<h1 id="features-used-16"><a class="header" href="#features-used-16">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Library Functions used (<code>stdin</code> and <code>stdout</code> from <code>context</code>)</li>
<li>Connections between functions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="print-args"><a class="header" href="#print-args">print-args</a></h1>
<h1 id="description-18"><a class="header" href="#description-18">Description</a></h1>
<p>A flow that takes the arguments passed to the flow on the command line and prints 
the first one (after the flow's source URL) out on standard output</p>
<h1 id="features-used-17"><a class="header" href="#features-used-17">Features Used</a></h1>
<ul>
<li>Root Flow</li>
<li>Library Functions used (<code>args</code> and <code>stdout</code> from <code>context</code>)</li>
<li>Connections between functions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flowstdlib-overview-1"><a class="header" href="#flowstdlib-overview-1"><code>flowstdlib</code> Overview</a></h1>
<p>See also: <a href="http://andrewdavidmackenzie.github.io/flow/code/doc/flowstdlib/index.html">Code docs</a></p>
<p><code>flowstdlib</code> is a standard library of functions and flows for <code>flow</code> programs to use.</p>
<h2 id="modules-1"><a class="header" href="#modules-1">Modules</a></h2>
<p><code>flowstdlib</code> contains the following modules:</p>
<ul>
<li><a href="docs/developing/../../flowstdlib/src/control/control.html"><code>control</code></a></li>
<li><a href="docs/developing/../../flowstdlib/src/data/data.html"><code>data</code></a></li>
<li><a href="docs/developing/../../flowstdlib/src/fmt/fmt.html"><code>fmt</code></a></li>
<li><a href="docs/developing/../../flowstdlib/src/math/math.html"><code>math</code></a></li>
</ul>
<h2 id="use-by-the-compiler-1"><a class="header" href="#use-by-the-compiler-1">Use by the Compiler</a></h2>
<p>In order for the compiler to be able to find the library's <code>flow</code> and <code>function</code> definitions, the directory containing
this library must be part of <code>FLOW_LIB_PATH</code> or specified using an instance of the <code>-L</code> command line option to <code>flowc</code>, </p>
<p>NOTE: That flows are compiled down to a graph of functions at compile time, and do not exist at runtime.</p>
<h2 id="building-this-library-from-source-1"><a class="header" href="#building-this-library-from-source-1">Building this library from Source</a></h2>
<p>Libraries like <code>flowstdlib</code> are built using <code>flowc</code> with the <code>-l</code> option. </p>
<p>This builds a directory tree (in <code>target/{lib_name}</code>) of all required files for a portable library, including:-</p>
<ul>
<li>documentation files (.md MarkDown files, .dot graphs of flows, graphs rendered as .dot.svg SVG files)</li>
<li>TOML definition files for flows and functions</li>
<li>Function implementations compiled to a .wasm WASM file</li>
<li>A <code>manifest.json</code> manifest of the libraries functions and where the implementations (.wasm files) can be found.
This is used by the Runtime to be able to load it.</li>
</ul>
<h2 id="dual-nature-of-flow-libraries-1"><a class="header" href="#dual-nature-of-flow-libraries-1">Dual nature of flow libraries</a></h2>
<p>Flow libraries such as <code>flowstdlib</code> have a dual nature. They can compiled and linked natively to a binary such
as <code>flowr</code>, or when compiled by <code>flowc</code> (using the <code>-l</code>) all the functions implementations are compiled to
<code>.wasm</code> WASM files.</p>
<h2 id="native-use-by-a-runtime-1"><a class="header" href="#native-use-by-a-runtime-1">Native use by a Runtime</a></h2>
<p><code>flowr</code> offers the <code>-n/--native</code> option for the <code>flowstdlib</code> to be used natively. When used, functions it
contains will be run natively (machine code), as opposed to WASM implementations of the functions.</p>
<h2 id="wasm-use-by-a-runtime-1"><a class="header" href="#wasm-use-by-a-runtime-1">WASM use by a Runtime</a></h2>
<p>If the <code>-n/--native</code> option is not used, and the library manifest (<code>manifest.json</code>) is found by the flow 
runner (e.g. <code>flowr</code>) at runtime (using<code>FLOW_LIB_PATH</code> or <code>-L</code>), then the manifest is read and the functions 
WASM implementations found and loaded.</p>
<p>When a job is executed that requires one of these library functions, the WASM implementation is run.</p>
<h2 id="configuring-flow_lib_path-during-development-1"><a class="header" href="#configuring-flow_lib_path-during-development-1">Configuring <code>FLOW_LIB_PATH</code> during development</a></h2>
<p>If you are using it as part of the larger <code>flow</code> workspace then you just need the <code>flow</code> project root directory
in your <code>FLOW_LIB_PATH</code> as described above (or added to the lib search part using the <code>-L &lt;dir&gt;</code> option).</p>
<h2 id="features-9"><a class="header" href="#features-9">features</a></h2>
<p>These are the conditionally compiled features of <code>flowstdlib</code>:</p>
<ul>
<li>default - No features are enabled by default</li>
<li>wasm - feature to enable compile of functions to WASM implementation. If not activated, the WASM implementations
will not be compiled and the library must be linked natively as described above.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-samples-1"><a class="header" href="#flow-samples-1">Flow Samples</a></h1>
<p>This crate contains a number of sample 'flows' that have been developed during the development
of the compiler and the run-time to drive the project development and demonstrate it working. </p>
<p>They also serve as a type of regression test to make sure we don't break any of the 
semantics that the samples rely on.</p>
<p>They range from the extremely simple &quot;hello-world&quot; example to more complex ones like generation of
a fibonacci series or a mandlebrot set image.</p>
<h2 id="structure-of-each-sample-1"><a class="header" href="#structure-of-each-sample-1">Structure of each sample</a></h2>
<p>Each sample directory contains:</p>
<ul>
<li>A <code>DESCRIPTION.md</code> file that:
<ul>
<li>describes what the <code>Flow</code> does</li>
<li>lists the features of <code>flow</code> that this sample uses and demonstrates</li>
</ul>
</li>
<li>A <code>root.toml</code> file that is the root file of the flow description</li>
<li>Files used in the automated testing of each sample:
<ul>
<li><code>test_arguments.txt</code> the arguments to be passed to the flow when running it</li>
<li><code>test_input.txt</code> the input supplied to the flow when running it</li>
<li><code>expected_output.txt</code> the output that the flow is expected to produce when invoked with 
<code>text_arguments.txt</code> and input <code>test_input.txt</code></li>
</ul>
</li>
</ul>
<h2 id="compiling-the-samples-1"><a class="header" href="#compiling-the-samples-1">Compiling the Samples</a></h2>
<p>The samples set has now been converted to a rust crate with a custom build script.</p>
<p>There is no dependency declared in Cargo.toml on the other crates (as you cannot currently declare a
dependency on a binary, just a lib), but in order to build, test and run this crate/folder you will need <code>flowc</code>
and <code>flowr</code> installed and on <code>$PATH</code> in order for build scripts to find them.</p>
<p>Using <code>cargo build -p flowsamples</code> causes the build script to run, and it compiles in-place the samples
using the <code>flowc</code> compiler.</p>
<h2 id="running-the-samples-1"><a class="header" href="#running-the-samples-1">Running the Samples</a></h2>
<p>Using <code>cargo run -p flowsamples</code> causes the sample runner in main.rs to run. It looks for sub-folders in
the samples folder and then executes the sample within. </p>
<p>When running them, it uses:</p>
<ul>
<li>test.arguments - arguments passed to the flow on the command line when executing it</li>
<li>test.input - test input to send to the sample flow using STDIN</li>
</ul>
<p>The output is sent to standard output.</p>
<p>To run a specific sample only use <code>cargo run -p flowsamples {sample-name}</code></p>
<h2 id="testing-the-samples-1"><a class="header" href="#testing-the-samples-1">Testing the Samples</a></h2>
<p>You can test all samples by using <code>cargo test -p flowsamples</code>,
it will run each one in turn with the pre-defined arguments and standard input.</p>
<p>It also gathers the standard output, standard error and files generated and checks for correctness 
by comparing them to previously generated content distributed with the package.</p>
<ul>
<li>If there is any standard error found in the file test.err then the test will fail.</li>
<li>If there is no standard error then it compares standard output captured in test.output to expected.output
and fails if there is a difference.</li>
<li>If an expected.file exists then it compares it to file output in test.file and fails if there is any 
difference with the expected file.</li>
</ul>
<pre><code>cargo test -p flowsamples 
    Finished test [unoptimized + debuginfo] target(s) in 0.11s
     Running target/debug/deps/samples-9e024e2c420db146

running 16 tests
test test::test_all_samples ... ignored
test test::test_args ... ok
test test::test_arrays ... ok
test test::test_factorial ... ok
test test::test_fibonacci ... ok
test test::test_hello_world ... ok
test test::test_mandlebrot ... ok
test test::test_matrix_mult ... ok
test test::test_pipeline ... ok
test test::test_prime ... ok
test test::test_primitives ... ok
test test::test_sequence ... ok
test test::test_sequence_of_sequences ... ok
test test::test_reverse_echo ... ok
test test::test_router ... ok
test test::test_tokenizer ... ok

test result: ok. 15 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out
</code></pre>
<p>NOTE: Until multiple instances of the client/server pair for running flows can be run at once, we 
need to restrict the test framework to only run one test at a time, otherwise by default it will run
multiple tests at once, and some will fail.</p>
<p>NOTE: At the moment, to make the progress more visible, each sample has a test manually added to it
in <code>samples/main.rs</code>, so for a new sample a test needs to be added by the author.</p>
<p>To test just one sample use <code>cargo test -p flowsamples {test-name}</code></p>
<pre><code>cargo test -p flowsamples test_factorial
    Finished test [unoptimized + debuginfo] target(s) in 0.12s
     Running target/debug/deps/samples-9e024e2c420db146

running 1 test
test test::test_factorial ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 15 filtered out
</code></pre>
<h2 id="default-workspace-member-crate-1"><a class="header" href="#default-workspace-member-crate-1">Default workspace member crate</a></h2>
<p>The <code>samples</code> crate is one of the <code>default-members</code> of the <code>flow</code> workspace project, so it is used if no 
particular package is supplied, thus the samples can also be built and run using:</p>
<ul>
<li><code>cargo build</code> : compile the samples using <code>flowc</code></li>
<li><code>cargo run</code>   : run the samples using <code>flowr</code></li>
<li><code>cargo test</code>  : run the samples using <code>flowr</code> and check the generated output is correct</li>
</ul>
<p>As other <code>default-members</code> are added to the workspace over time, those commands may do other things, so
just be aware that if you only want to run the samples the <code>-p samples</code> option above will be safer.</p>
<h2 id="flowsamples-executable-1"><a class="header" href="#flowsamples-executable-1"><code>flowsamples</code> executable</a></h2>
<p>There is also an executable (<code>bin</code> or binary) installed with the library called <code>flowsamples</code> that if run
without any arguments will run all the samples. You can supply it the name of a sample (the name of the folder
under <code>samples</code> where the sample is) to run just that one sample.</p>
<h2 id="developing-a-new-sample-1"><a class="header" href="#developing-a-new-sample-1">Developing a new sample</a></h2>
<p>To develop a new sample, just create a new folder under 'samples' with your sample name. </p>
<p>Add the root.toml and any other included flows and describe them.</p>
<p>Add a DESCRIPTION.md file that describes what the sample does and what features of flow it uses.</p>
<p>Add an entry in the guide's &quot;samples&quot; section that will include the DESCRIPTION.md file above.</p>
<h2 id="features-10"><a class="header" href="#features-10">features</a></h2>
<p><code>flowsamples</code> has no features to enable</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="important-make-targets"><a class="header" href="#important-make-targets">Important make targets</a></h2>
<ul>
<li>(default) <code>make</code> will build, run local tests and generate docs.</li>
<li><code>make build-guide</code> will just generate the HTML for the guide if you are writing docs. But better
would be to just <code>cd guide &amp;&amp; mdbook serve</code> as that will track and update the generated content as 
you make changes, allowing you to view them instantly with a browser refresh.</li>
<li><code>make test</code> this should be what you run to check changes you have made work OK. At the moment it is the 
same as 'make travis' until I re-instate some tests I was having issues with.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h2>
<p>There are many ways of contributing</p>
<ul>
<li>adding an issue with a bug report of an enhancement request or new feature idea</li>
<li>pick up a <a href="https://github.com/andrewdavidmackenzie/flow/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22">help wanted</a> issue and try and fix it</li>
<li>adding to or correcting the docs and this guide</li>
<li>adding a new sample</li>
<li>improvements to the libraries, compiler, standard library, run-time</li>
<li>improvements to unit or integration tests</li>
<li>improvements to build processes (e.g. getting coverage reports working etc)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="issues"><a class="header" href="#issues">Issues</a></h3>
<p>Issues can be found in the <a href="https://github.com/andrewdavidmackenzie/flow/issues">repo</a>, if you are not yet a 
project contributor then just add a comment to one to say you'd like to work on it and I will avoid doing
the same. </p>
<p>I work on issues KanBan style in this <a href="https://github.com/andrewdavidmackenzie/flow/projects/2">Github Project</a></p>
<p>Adding new issues you find can also be helpful, although with my limited time on the project, fixing issues
and sending PRs are more welcome! :-)</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="prs"><a class="header" href="#prs">PRs</a></h3>
<p>If you want to contribute a code or test or docs or tolling change....</p>
<ul>
<li>if no existing issue exists for it, create one so we can agree on what to do before starting (a good idea 
to make later PR merges easier to accept I think!)</li>
<li>if an issue exists already add a comment to it so I know you want to work on it</li>
<li>fork the repo</li>
<li>create a branch for the issue in your repo</li>
<li>make your changes and update tests, docs and samples as required</li>
<li>run tests ('make travis') before pushing to your branch</li>
<li>wait for Travis to pass</li>
<li>submit the PR, referencing the issue is a good idea</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-samples-2"><a class="header" href="#flow-samples-2">Flow Samples</a></h1>
<p>This crate contains a number of sample 'flows' that have been developed during the development
of the compiler and the run-time to drive the project development and demonstrate it working. </p>
<p>They also serve as a type of regression test to make sure we don't break any of the 
semantics that the samples rely on.</p>
<p>They range from the extremely simple &quot;hello-world&quot; example to more complex ones like generation of
a fibonacci series or a mandlebrot set image.</p>
<h2 id="structure-of-each-sample-2"><a class="header" href="#structure-of-each-sample-2">Structure of each sample</a></h2>
<p>Each sample directory contains:</p>
<ul>
<li>A <code>DESCRIPTION.md</code> file that:
<ul>
<li>describes what the <code>Flow</code> does</li>
<li>lists the features of <code>flow</code> that this sample uses and demonstrates</li>
</ul>
</li>
<li>A <code>root.toml</code> file that is the root file of the flow description</li>
<li>Files used in the automated testing of each sample:
<ul>
<li><code>test_arguments.txt</code> the arguments to be passed to the flow when running it</li>
<li><code>test_input.txt</code> the input supplied to the flow when running it</li>
<li><code>expected_output.txt</code> the output that the flow is expected to produce when invoked with 
<code>text_arguments.txt</code> and input <code>test_input.txt</code></li>
</ul>
</li>
</ul>
<h2 id="compiling-the-samples-2"><a class="header" href="#compiling-the-samples-2">Compiling the Samples</a></h2>
<p>The samples set has now been converted to a rust crate with a custom build script.</p>
<p>There is no dependency declared in Cargo.toml on the other crates (as you cannot currently declare a
dependency on a binary, just a lib), but in order to build, test and run this crate/folder you will need <code>flowc</code>
and <code>flowr</code> installed and on <code>$PATH</code> in order for build scripts to find them.</p>
<p>Using <code>cargo build -p flowsamples</code> causes the build script to run, and it compiles in-place the samples
using the <code>flowc</code> compiler.</p>
<h2 id="running-the-samples-2"><a class="header" href="#running-the-samples-2">Running the Samples</a></h2>
<p>Using <code>cargo run -p flowsamples</code> causes the sample runner in main.rs to run. It looks for sub-folders in
the samples folder and then executes the sample within. </p>
<p>When running them, it uses:</p>
<ul>
<li>test.arguments - arguments passed to the flow on the command line when executing it</li>
<li>test.input - test input to send to the sample flow using STDIN</li>
</ul>
<p>The output is sent to standard output.</p>
<p>To run a specific sample only use <code>cargo run -p flowsamples {sample-name}</code></p>
<h2 id="testing-the-samples-2"><a class="header" href="#testing-the-samples-2">Testing the Samples</a></h2>
<p>You can test all samples by using <code>cargo test -p flowsamples</code>,
it will run each one in turn with the pre-defined arguments and standard input.</p>
<p>It also gathers the standard output, standard error and files generated and checks for correctness 
by comparing them to previously generated content distributed with the package.</p>
<ul>
<li>If there is any standard error found in the file test.err then the test will fail.</li>
<li>If there is no standard error then it compares standard output captured in test.output to expected.output
and fails if there is a difference.</li>
<li>If an expected.file exists then it compares it to file output in test.file and fails if there is any 
difference with the expected file.</li>
</ul>
<pre><code>cargo test -p flowsamples 
    Finished test [unoptimized + debuginfo] target(s) in 0.11s
     Running target/debug/deps/samples-9e024e2c420db146

running 16 tests
test test::test_all_samples ... ignored
test test::test_args ... ok
test test::test_arrays ... ok
test test::test_factorial ... ok
test test::test_fibonacci ... ok
test test::test_hello_world ... ok
test test::test_mandlebrot ... ok
test test::test_matrix_mult ... ok
test test::test_pipeline ... ok
test test::test_prime ... ok
test test::test_primitives ... ok
test test::test_sequence ... ok
test test::test_sequence_of_sequences ... ok
test test::test_reverse_echo ... ok
test test::test_router ... ok
test test::test_tokenizer ... ok

test result: ok. 15 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out
</code></pre>
<p>NOTE: Until multiple instances of the client/server pair for running flows can be run at once, we 
need to restrict the test framework to only run one test at a time, otherwise by default it will run
multiple tests at once, and some will fail.</p>
<p>NOTE: At the moment, to make the progress more visible, each sample has a test manually added to it
in <code>samples/main.rs</code>, so for a new sample a test needs to be added by the author.</p>
<p>To test just one sample use <code>cargo test -p flowsamples {test-name}</code></p>
<pre><code>cargo test -p flowsamples test_factorial
    Finished test [unoptimized + debuginfo] target(s) in 0.12s
     Running target/debug/deps/samples-9e024e2c420db146

running 1 test
test test::test_factorial ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 15 filtered out
</code></pre>
<h2 id="default-workspace-member-crate-2"><a class="header" href="#default-workspace-member-crate-2">Default workspace member crate</a></h2>
<p>The <code>samples</code> crate is one of the <code>default-members</code> of the <code>flow</code> workspace project, so it is used if no 
particular package is supplied, thus the samples can also be built and run using:</p>
<ul>
<li><code>cargo build</code> : compile the samples using <code>flowc</code></li>
<li><code>cargo run</code>   : run the samples using <code>flowr</code></li>
<li><code>cargo test</code>  : run the samples using <code>flowr</code> and check the generated output is correct</li>
</ul>
<p>As other <code>default-members</code> are added to the workspace over time, those commands may do other things, so
just be aware that if you only want to run the samples the <code>-p samples</code> option above will be safer.</p>
<h2 id="flowsamples-executable-2"><a class="header" href="#flowsamples-executable-2"><code>flowsamples</code> executable</a></h2>
<p>There is also an executable (<code>bin</code> or binary) installed with the library called <code>flowsamples</code> that if run
without any arguments will run all the samples. You can supply it the name of a sample (the name of the folder
under <code>samples</code> where the sample is) to run just that one sample.</p>
<h2 id="developing-a-new-sample-2"><a class="header" href="#developing-a-new-sample-2">Developing a new sample</a></h2>
<p>To develop a new sample, just create a new folder under 'samples' with your sample name. </p>
<p>Add the root.toml and any other included flows and describe them.</p>
<p>Add a DESCRIPTION.md file that describes what the sample does and what features of flow it uses.</p>
<p>Add an entry in the guide's &quot;samples&quot; section that will include the DESCRIPTION.md file above.</p>
<h2 id="features-11"><a class="header" href="#features-11">features</a></h2>
<p><code>flowsamples</code> has no features to enable</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="continuous-integration-testing-of-flow"><a class="header" href="#continuous-integration-testing-of-flow">Continuous Integration testing of flow</a></h3>
<p>The CI build and test run in Travis on each push to a branch or PR can be run locally 
using <code>make travis</code>.</p>
<p>These tests include unit and integration tests, rust doc-tests and it also compiles, generates, runs and checks the 
output of all the samples found in the ./samples folder.</p>
<p>This will also rebuild the guide locally.</p>
<p>I recommend to make sure this runs without errors and passes before pushing to GitHub.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="internals-overview"><a class="header" href="#internals-overview">Internals Overview</a></h2>
<p>In this section we provide some more details on what flowc does when you use it to compile, generate, build and run a flow.</p>
<p>The process includes these areas described in more detail in the following pages:</p>
<ul>
<li>Flow loading: the process of reading in the flow description and building an internal representation of it</li>
<li>Flow compiling: take hierarchical flows representation loaded from previous stage and &quot;compile down&quot; to one more 
suited for project for flow project generation for execution.</li>
<li>Flow execution: The generated project is loaded by the generic run-time library (flowrlib) and the functions are executed in turn.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flow-loading"><a class="header" href="#flow-loading">Flow Loading</a></h2>
<p>Read in the hierarchical definition, recursively reading all nested flows until everything loaded.</p>
<p>Build the connections between values, functions, input and outputs using the 
unaliased routes to functions and subflows.</p>
<p>Check that the from/to types on connections match.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flow-compiling"><a class="header" href="#flow-compiling">Flow Compiling</a></h2>
<p>From the hierarchical definition of a flow program produced by the loading stage:</p>
<h3 id="connection-reducing"><a class="header" href="#connection-reducing">Connection Reducing</a></h3>
<p>Build a flat table of connections.</p>
<p>For every connection that ends at a flow:</p>
<ul>
<li>Look through all other connections and for each one that starts where this flow starts:
<ul>
<li>Replace the connection's destination with this connections destination.</li>
<li>Delete this connection</li>
</ul>
</li>
</ul>
<p>When done there should be no connections ending at flows.
Any connections left that starts at a flow, is unconnected and can be deleted.</p>
<h3 id="value-and-function-tables"><a class="header" href="#value-and-function-tables">Value and Function Tables</a></h3>
<p>Build a table of values and functions.</p>
<h3 id="pruning-value-and-function-tables"><a class="header" href="#pruning-value-and-function-tables">Pruning Value and Function Tables</a></h3>
<p>Drop the following combinations, with warnings:</p>
<ul>
<li>values that don't have connections from them.</li>
<li>values that have only outputs and are not initialized.</li>
<li>functions that don't have connections from their output.</li>
<li>functions that don't have connections to all their inputs.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flow-execution"><a class="header" href="#flow-execution">Flow Execution</a></h2>
<p>In this section we describe how a flow is executed by a flow runner.</p>
<h3 id="components-of-execution"><a class="header" href="#components-of-execution">Components of Execution</a></h3>
<p>A compiled flow consists of:</p>
<ul>
<li>Context functions - references to functions provided by the flow runner</li>
<li>Flow functions - references to functions used in the flow</li>
<li>Connections - connections between a function's output and one or more other functions' inputs</li>
<li>Jobs - created by the runner as execution progresses</li>
</ul>
<h4 id="context-functions-2"><a class="header" href="#context-functions-2">Context Functions</a></h4>
<p>Context functions are functions provided by the flow runner program for interacting with the surrounding
execution environment, such things as standard IO, file system, etc. </p>
<p>These are &quot;impure&quot; functions where the outputs are not derived solely from the inputs. 
Some of them will have inputs only (e.g. a stdout &quot;print&quot; function).
Some of them will have outputs only (e.g. a stdin &quot;readline&quot; function)
None of them will have inputs AND outputs.</p>
<h4 id="flow-functions"><a class="header" href="#flow-functions">Flow Functions</a></h4>
<p>A flow is a graph of connected functions (including Context functions) where outputs of one function are
connected to inputs of another. A flow references the functions used, that may come either from a library 
or provided by the flow itself via custom source functions that are compiled to WASM for running by the
flow runner.</p>
<p>These functions are all &quot;pure&quot; with no side-effects and the outputs are solely derived from the inputs, 
in a reliable way.
A function does not store any value or state.</p>
<p>Such functions must have one or more defined inputs and an output, as a (non-Context) function without
an input cannot receive data to run with and will never be invoked and an (non-Context) function
without an output has no effect and does not need to be run.</p>
<p>A function has only one output. But the output may produce structured data, and a connection can be
made from a data element to another function's input using the &quot;output route&quot; selector.</p>
<p>A functions output will be connected to one or more other functions inputs. It is possible to connect 
a functions output back to one of it's input for the purpose of recursion or iteration. These are
called &quot;loopback&quot; connections.</p>
<p>A Function can only run when a value is available at each of it's inputs and the destinations it sends values
to are all free to send to. It is blocked from running until these conditions are met.</p>
<p>When the (job that uses the) function completes, it will produce an optional output value. If so, a 
copy of this output value (or part of it via an &quot;Output route&quot;) will be sent to each connected 
destination function's input, possibly enabling them to run.</p>
<h5 id="runagain-and-the-completed-state"><a class="header" href="#runagain-and-the-completed-state">&quot;RunAgain&quot; and the Completed State</a></h5>
<p>A function also returns a &quot;RunAgain&quot; value that indicates if it can/should be run again by the runner. 
This is usually for use in Context functions, such as the case of reading from standard in, say using &quot;readline&quot;.</p>
<p>The &quot;readline&quot; function can be invoked many times, each time it will read a line of text from the standard
input and return TRUE for RunAgain, until EOF is reached when it will return FALSE for RunAgain.</p>
<p>When that happens the runner will put the function in the <code>Completed</code> state and it will not be invoked
again for the remained of this flow's execution.</p>
<h5 id="input-initializers"><a class="header" href="#input-initializers">Input Initializers</a></h5>
<p>A functions inputs in a flow can be configured with an &quot;Input Initializer&quot;, they are not part of the function's
definition, allowing them to be re-used in multiple flows or locations in a flow with different 
initializers.</p>
<p>An initializer can be of type &quot;Once&quot; where the input value is initialized with the provided value just once,
or of type &quot;Constant&quot;, in which case the input is re-initialized with the provided value each time after
it has run. Once an input is supplied the value from the initializer, everything functions the same as if
the value had come from another function's output.</p>
<h4 id="connections-1"><a class="header" href="#connections-1">Connections</a></h4>
<p>Values in the flow graph proceed via connections between function's outputs and functions inputs.
An output can be the entire value produced or a part of it selected via an &quot;Output Route&quot;.
On a given execution a function may produce or not an output.
Also, the output data structure may vary and an &quot;Output Route&quot; may or may not have data in it.</p>
<p>If no value present, then nothing is sent to the destination function's input and it will remain waiting.</p>
<h4 id="jobs"><a class="header" href="#jobs">Jobs</a></h4>
<p>Jobs are created in order to execute a function, with a given set of inputs.
Initially they contain inpout values and a reference to the function to execute.
Once run, they will also contain the results (&quot;RunAgain&quot; and an Optional value produced)</p>
<h3 id="generalized-rules"><a class="header" href="#generalized-rules">Generalized Rules</a></h3>
<ul>
<li>Functions can have zero or more inputs</li>
<li>Each input can be connected to one or more Outputs that may send values to it during execution</li>
<li>Each (non-Context) function has one output, that can send values to one or more destinations</li>
<li>Non-Context functions must have 1 or more inputs and an output</li>
<li>Connections to destinations may consume the whole output value/struct, or may select a portion of it using a route</li>
<li>If no output is produced, or there is no value at the selected route, then nothing is sent to destinations</li>
<li>Can only be run (via a Job) once a value is available at each of the inputs and the output is
free to send to the destinations it is connected to. Is blocked from running until these conditions are met</li>
<li>Once ran, it produces an output that is sent to all destinations connected to its output</li>
<li>Each of the destinations consumes (a copy of) the output value only once</li>
<li>Once the output has been consumed (once) by all of the destinations, then the function may be ran again</li>
<li>The only thing that determines if a function is available to run is the availability of data at its inputs, and the ability to produce the result at its output by the destination inputs being free.</li>
<li>If a destination function hasn't consumed its input, then the first function will be blocked. </li>
<li>A flow's execution ends when there are no functions left in the &quot;ready&quot; state available for execution</li>
</ul>
<h3 id="parallelized-execution"><a class="header" href="#parallelized-execution">Parallelized Execution</a></h3>
<p>A core goal of 'flow' is to enable parallel execution of programs, without explicitly programming the
parallel execution, but allowing the inherent parallelism in an algorithm to occur.</p>
<p>This is possible due to a flow definition being done by describing functions on data, with the data dependencies
being explicit via &quot;Connections&quot; between functions and execution not occurring until data is available.</p>
<p>Thus, multiple instances of functions (via Jobs containing input data then output results) maybe executing 
in parallel as governed by the data dependency and execution rules above, and in fact multiple instances of
the same function (in different jobs) maybe executing in parallel.</p>
<p>The level of parallelism is determined by the algorithm as defined in the flow, the flow execution rules
and the number of cores in the execution machine(s) executing jobs.</p>
<h4 id="execution-order"><a class="header" href="#execution-order">Execution Order</a></h4>
<p>Dataflow execution like that done by 'flow', and especially if parallel execution is performed, does not
guarantee any specific order of function/job execution or completion. Data dependencies expressed in the flow
should govern results.</p>
<p>This requires some unlearning of rules learned in previous procedural languages and some assumptions are
no longer valid. e.g. a Range of numbers from 0..10, could &quot;appear&quot; as data values in the graph as
3,8,1,2,0,9,6,5,7,4 instead of the expected 0,1,2,3,4,5,6,7,8,9. </p>
<p>If a specific order is required in output data, then either the algorithm should enforce it inherently,
or some specific functions that impose order can be used (preferably just prior to output) at the expense
of parallelism.</p>
<p>At a given time, in the flow graph there can be a number of functions ready for execution and having 
Jobs created for them. They maybe executed in different orders by the runner, while still producing
&quot;correct&quot; output (e.g. if order of output is not important, two different orders of output values are both
considered &quot;correct&quot;). </p>
<p>The 'flowr' runner two <code>ExecutionStrategy</code> that affect the order of job execution:</p>
<ul>
<li>&quot;InOrder&quot; - execution is in the order that they became ready to execute - first come first served</li>
<li>&quot;Random&quot; - functions are selected at random from within the set of those <code>Ready</code></li>
</ul>
<p>Note that the time taken to execute different jobs may be different, and each may vary on a given machine
and of the flow is distributed across a network then other effects and other machines can affect Job execution, and 
hence Job completion time. So, beyond the different execution orders mentioned above, there are also no 
guarantees about job completion order. Flow programs should be programmed to be robust to this.</p>
<h3 id="execution-states"><a class="header" href="#execution-states">Execution States</a></h3>
<p>Prior to initialization, all functions will be in the <code>Initial</code> state. </p>
<p>The Initialization step described below is run, after which all functions will be in one or more of the 
following states (see <code>State</code> struct in <code>run_state.rs</code>):</p>
<ul>
<li><code>Ready</code> - Inputs are satisfied, the Output destinations are free and it can be run</li>
<li><code>Blocked</code>- One or more destination inputs this functions sends to is full, blocking execution</li>
<li><code>Waiting</code> - One or more of the inputs lack data, so the function cannot run</li>
<li><code>Running</code> - There is at least one job running that is using this function</li>
<li><code>Completed</code> - The function has returned FALSE for &quot;RunAgain&quot; and is not available for execution</li>
</ul>
<h2 id="execution-process"><a class="header" href="#execution-process">Execution Process</a></h2>
<h3 id="submission"><a class="header" href="#submission">Submission</a></h3>
<p>A flow is sent for execution by a client application sending a <code>Submission</code> containing a reference to the 
compiled flow manifest to the runner application.</p>
<h3 id="loading"><a class="header" href="#loading">Loading</a></h3>
<p>All functions are loaded as they are read from the flow manifest. If they refer to library functions, then
they are loaded from the library reference (either a pre-loaded native implementation or a WASM implementation).</p>
<p>If they are WASM implementations supplied by the flow itself, then they are also loaded.</p>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<p>Any functions with &quot;Input Initializers&quot; (&quot;Once&quot; or &quot;Constant&quot; types) will have the relevant inputs initialized 
with the specified value.</p>
<p>This may satisfy the function's need for input data and then it will be set into the <code>Ready</code> state.</p>
<p>Since the function's input is full, this may cause a block on other functions pending to send to that input.</p>
<p>Some Context functions that have no inputs (e.g. stdin &quot;readline&quot;) may be placed immediately into the <code>Ready</code>
state (they are always ready until they return FALSE to &quot;RunAgain).</p>
<p>Now, the execution loop is started.</p>
<h3 id="execution-loop-1"><a class="header" href="#execution-loop-1">Execution Loop</a></h3>
<p>A function in the <code>Ready</code> state is selected to run (depending on the <code>ExecutionStrategy</code> discussed above).</p>
<p>A Job is created using the function's available input values and is sent for execution.</p>
<ul>
<li>this may unblock another function which was blocked sending to this functions as it's input was full</li>
</ul>
<p>Jobs are created until either no function is available in the <code>Ready</code> state, or a maximum number of pending Jobs
is reached.</p>
<p>A blocking wait on completed jobs is performed. 
For each completed job that is received:</p>
<ul>
<li>Any output value in the Result (whole or using an &quot;Output Route to select part of the data) is made available to 
inputs on connected functions
<ul>
<li>This may satisfy the inputs of the other function, causing them to transition to the <code>Ready</code> state</li>
</ul>
</li>
</ul>
<p>If the function has any &quot;Constant&quot; initializer on any of it's inputs, it is run, possible refilling one or more
of its inputs.
According to the availability of data at its inputs and ability to send to its outputs a function may transition
to the <code>Ready</code> or <code>Waiting</code> (for inputs) or <code>Blocked</code> (on sending) state. </p>
<p>The loop continues until there are no functions in the <code>ready</code>state, and the flow is terminated.</p>
<h3 id="termination"><a class="header" href="#termination">Termination</a></h3>
<p>The execution of a flow terminates when there are no functions left on the ready list.
Depending on options used and the runner, this may cause the output of some statistics, unloading
of loaded objects and either runner program exit, or return to wait for a <code>Submission</code> and the whole
process starts again.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flow-execution-state-machine"><a class="header" href="#flow-execution-state-machine">Flow Execution State Machine</a></h2>
<h3 id="states"><a class="header" href="#states">States</a></h3>
<p>Prior to initialization, all functions will be in the <code>Initial</code> state.</p>
<p>The Initialization step described below is run, after which all functions will be in one or more of the
following states (see <code>State</code> struct in <code>run_state.rs</code>):</p>
<ul>
<li><code>Ready</code> - Inputs are satisfied, the Output destinations are free and it can be run</li>
<li><code>Blocked</code>- One or more destination inputs this functions sends to is full, blocking execution</li>
<li><code>Waiting</code> - One or more of the inputs lack data, so the function cannot run</li>
<li><code>Running</code> - There is at least one job running that is using this function</li>
<li><code>Completed</code> - The function has returned FALSE for &quot;RunAgain&quot; and is not available for execution</li>
</ul>
<h3 id="events-that-cause-state-changes"><a class="header" href="#events-that-cause-state-changes">Events that cause state changes</a></h3>
<p>The following top level events trigger evaluation of a function's state using the state variables and may cause 
a function to transition to a new state:</p>
<ul>
<li><code>NewJob</code>- A new job is created by the runner for a specific function, taking values from its inputs. This will 
cause the flow containing the function in the job to also be marked as busy, preventing functions from outside the 
flow sending to it while it is busy. Functions inside the same flow that were previously blocked sending to 
this function are now unblocked as the inputs are available to send to (unblock_internal_flow_senders). Functions 
from outside the flow attempting to send to it are blocked by &quot;flow_blocks&quot; that are
removed when the flow goes idle later (as all the functions within it go idle).</li>
<li><code>JobDone</code> - a job that was using a function completes, returning a result to the runner that includes the 
<code>run_again</code>value. 
This may cause a change in state in the function that was running in the job, and via the <code>ValueReceived</code> event 
below it may also affect other functions it sends values to.</li>
<li><code>ValueReceived</code> - a function receives a value on one of its inputs, caused either by:
<ul>
<li>An &quot;Input Initializer&quot; on the function being run</li>
<li>A value was sent to it from another function on <code>JobDone</code></li>
<li>A value was sent to it from itself upon <code>JobDone</code> (loopback)</li>
</ul>
</li>
<li><code>UnBlock</code> - previously a function was blocked from running as a destination it sends to had it's inputs full. That 
function ran and it's inputs were freed, and it is not blocked on any other destination so the sender can now be 
unblocked. Functions that were blocked sending to the function being used in the job <em>may</em> become unblocked and so 
produces multiple UnBocks</li>
</ul>
<h3 id="state-variables"><a class="header" href="#state-variables">State Variables</a></h3>
<p>State variables for a function can be calculated at any time based on its inputs states, and other functions states.
They are used in determining the next state that a function should be transitioned to when an event occurs:</p>
<ul>
<li><code>needs_input</code> - the function has at least one input that has no data on it, and so the function cannot run</li>
<li><code>output_blocked</code> - the function has at least one destination input that is full and so it cannot send a result
value to that destination, hence the function cannot run</li>
</ul>
<h3 id="state-transitions"><a class="header" href="#state-transitions">State Transitions</a></h3>
<p>An event may cause the affected functions to transition to a new state, based on its state variables:</p>
<ul>
<li><code>NewJob</code>
<code>Ready</code> --&gt; <code>Running</code>     - The function used in the job transitions to <code>Running</code></li>
<li><code>JobDone</code> (job_done)
<code>Running</code> --&gt; <code>Completed</code> - !<code>run_again</code>                                        (job_done)
<code>Running</code> --&gt; <code>Waiting</code>   -  <code>run_again</code> &amp;&amp;  <code>needs_input</code>
<code>Running</code> --&gt; <code>Blocked</code>   -  <code>run_again</code> &amp;&amp; !<code>needs_input</code> &amp;&amp; <code>output_blocked</code>  (make_ready_or_blocked)
<code>Running</code> --&gt; <code>Ready</code>     -  <code>run_again</code> &amp;&amp; !<code>needs_input</code> &amp;&amp; !<code>output_blocked</code> (make_ready_or_blocked)</li>
<li><code>ValueReceived</code> - a function receives a value on one of its inputs.             (send_a_value)
<code>Waiting</code> --&gt; <code>Waiting</code>   -  <code>needs_input</code>
<code>Waiting</code> --&gt; <code>Blocked</code>   - !<code>needs_input</code> &amp;&amp; <code>output_blocked</code>  (make_ready_or_blocked)
<code>Blocked</code> --&gt; <code>Blocked</code>   - !<code>needs_input</code> &amp;&amp; <code>output_blocked</code>  (make_ready_or_blocked)
<code>Waiting</code> --&gt; <code>Ready</code>     - !<code>needs_input</code> &amp;&amp; !<code>output_blocked</code> (make_ready_or_blocked)</li>
<li><code>UnBlock</code> - (remove_blocks) &lt;-- (unblock_flows, unblock_internal_flow_senders) &lt;-- (job_done)
<code>Blocked</code> --&gt; <code>Ready</code></li>
</ul>
<h3 id="state-transition-diagram"><a class="header" href="#state-transition-diagram">State Transition Diagram</a></h3>
<pre><code>                         +---------+
                         | Initial |
                         +---------+
                              |
                              |ValueReceived (via InputInitializer)
                              v
            UnBlock      +---------+    ValueReceived
       +---------------&gt; |  Ready  |&lt;--------------------+
       |                 +---------+                     |
       |                  ^       |                      |
       |           JobDone|       |NewJob                |
  +---------+             |       |                   +---------+
  | Blocked |&lt;------------|-------|-------------------| Waiting |
  +---------+             |       |                   +---------+
       ^                  |       |                        ^
       |                  |       v                        |
       |   JobDone       +---------+      JobDone          |
       +-----------------| Running |-----------------------+
                         +---------+        
                              |
                              |JobDone
                              v
                         +---------+
                         |Completed|
                         +---------+
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
